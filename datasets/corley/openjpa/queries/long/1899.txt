I have a simple example.  A customer has a reference to an address and a (primary) contact (an extension of person).  Find the customer, get the contact and evict it from L2.  Now find the customer again using a new entity manager.  Begin a Tx and change the address of the contact and then call Customer.getPrimaryContact() (this is important)   Rollback the Tx.  Now find the customer again using another new EntityManager and call Customer.getPrimaryContact().getAddress().  The address associated with the contact is Null and not the original address as expected.  The same scenario works fine under OpenJPA 1.2.2.  

The reason this is a big problem for us is we use L2 caching in our application and the application is clustered.  The same problem occurs if different nodes in the cluster operate on the same objects.  In a cluster "evict" is not directly called, but the RemoteCommitProvider will evict the L2 and create the same problem.  

I have attached example code to reproduce the problem using a single JVM and calling Evict.  I also have another example where you can deploy the code on two nodes in a cluster and see the problem occurs that way as well.  Each example contains Unix shell scripts and Windows cmd files as well.  Each are paired for JPA 1.0 and JPA 2.0.  Again, the problem only occurs under JPA 2.0.

This is a block for us.  We cannot ship our product with this type of problem as it means objects and their graph can be corrupted.  