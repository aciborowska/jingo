When calling zookeeper.close(handle), any connection watcher for the handle is not deleted. This is a source of memory leaks for applications that create and close lots of connections. Its damage can be mitigated to some degree by changing the watcher to some function that won't keep references to instances alive before calling close.

The fix is just to add a free_pywatcher(..) call in the close sequence. Alternatively you could allow set_watcher(handle, None) as a way of deleting the watcher, but it's probably best to take care of it on close too.