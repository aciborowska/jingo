The following query:

``` xquery
function ($x) {
    $x
}("hello")
```

Results an exception from the parser:

```
org.xmldb.api.base.XMLDBException: exerr:ERROR <AST>:0:0: unexpected AST node: DynamicFunction
 [at line 6, column 10]
    at org.exist.xmldb.LocalXPathQueryService.compile(LocalXPathQueryService.java:259)
    at org.exist.client.QueryDialog$QueryThread.run(QueryDialog.java:600)
Caused by: org.exist.xquery.StaticXQueryException: exerr:ERROR <AST>:0:0: unexpected AST node: DynamicFunction
 [at line 6, column 10]
    at org.exist.xquery.XQuery.compile(XQuery.java:165)
    at org.exist.xquery.XQuery.compile(XQuery.java:109)
    at org.exist.xquery.XQuery.compile(XQuery.java:93)
    at org.exist.xquery.XQuery.compile(XQuery.java:85)
    at org.exist.xmldb.LocalXPathQueryService.compileAndCheck(LocalXPathQueryService.java:272)
    at org.exist.xmldb.LocalXPathQueryService.compile(LocalXPathQueryService.java:257)
    ... 1 more
Caused by: <AST>:0:0: unexpected AST node: DynamicFunction
    at org.exist.xquery.parser.XQueryTreeParser.expr(XQueryTreeParser.java:3787)
    at org.exist.xquery.parser.XQueryTreeParser.mainModule(XQueryTreeParser.java:4220)
    at org.exist.xquery.parser.XQueryTreeParser.module(XQueryTreeParser.java:4153)
    at org.exist.xquery.parser.XQueryTreeParser.xpath(XQueryTreeParser.java:3807)
    at org.exist.xquery.XQuery.compile(XQuery.java:160)
    ... 6 more
Caused by: org.exist.xquery.StaticXQueryException: exerr:ERROR <AST>:0:0: unexpected AST node: DynamicFunction
 [at line 6, column 10]
    at org.exist.xquery.XQuery.compile(XQuery.java:165)
    at org.exist.xquery.XQuery.compile(XQuery.java:109)
    at org.exist.xquery.XQuery.compile(XQuery.java:93)
    at org.exist.xquery.XQuery.compile(XQuery.java:85)
    at org.exist.xmldb.LocalXPathQueryService.compileAndCheck(LocalXPathQueryService.java:272)
    at org.exist.xmldb.LocalXPathQueryService.compile(LocalXPathQueryService.java:257)
    at org.exist.client.QueryDialog$QueryThread.run(QueryDialog.java:600)
Caused by: <AST>:0:0: unexpected AST node: DynamicFunction
    at org.exist.xquery.parser.XQueryTreeParser.expr(XQueryTreeParser.java:3787)
    at org.exist.xquery.parser.XQueryTreeParser.mainModule(XQueryTreeParser.java:4220)
    at org.exist.xquery.parser.XQueryTreeParser.module(XQueryTreeParser.java:4153)
    at org.exist.xquery.parser.XQueryTreeParser.xpath(XQueryTreeParser.java:3807)
    at org.exist.xquery.XQuery.compile(XQuery.java:160)
```

The trace of the XQuery parse tree looks like:

```
 > xpath; LA(1)==function
  > module; LA(1)==function
   > mainModule; LA(1)==function
    > prolog; LA(1)==function
    < prolog; LA(1)==function
    > queryBody; LA(1)==function
     > expr; LA(1)==function
      > exprSingle; LA(1)==function
       > orExpr; LA(1)==function
        > andExpr; LA(1)==function
         > comparisonExpr; LA(1)==function
          > stringConcatExpr; LA(1)==function
           > rangeExpr; LA(1)==function
            > additiveExpr; LA(1)==function
             > multiplicativeExpr; LA(1)==function
              > unionExpr; LA(1)==function
               > intersectExceptExpr; LA(1)==function
                > instanceofExpr; LA(1)==function
                 > treatExpr; LA(1)==function
                  > castableExpr; LA(1)==function
                   > castExpr; LA(1)==function
                    > unaryExpr; LA(1)==function
                     > valueExpr; LA(1)==function
                      > pathExpr; LA(1)==function
                       > relativePathExpr; LA(1)==function
                        > stepExpr; LA(1)==function
                         > qName; [guessing]LA(1)==function
                          > ncnameOrKeyword; [guessing]LA(1)==function
                           > reservedKeywords; [guessing]LA(1)==function
                           < reservedKeywords; [guessing]LA(1)==(
                          < ncnameOrKeyword; [guessing]LA(1)==(
                          > ncnameOrKeyword; [guessing]LA(1)==function
                           > reservedKeywords; [guessing]LA(1)==function
                           < reservedKeywords; [guessing]LA(1)==(
                          < ncnameOrKeyword; [guessing]LA(1)==(
                         < qName; [guessing]LA(1)==(
                         > postfixExpr; LA(1)==function
                          > primaryExpr; LA(1)==function
                           > functionItemExpr; LA(1)==function
                            > inlineFunctionExpr; LA(1)==function
                             > annotations; LA(1)==function
                             < annotations; LA(1)==function
                             > paramList; LA(1)==$
                              > param; LA(1)==$
                               > qName; LA(1)==x
                                > ncnameOrKeyword; [guessing]LA(1)==x
                                < ncnameOrKeyword; [guessing]LA(1)==)
                                > ncnameOrKeyword; LA(1)==x
                                < ncnameOrKeyword; LA(1)==)
                               < qName; LA(1)==)
                              < param; LA(1)==)
                             < paramList; LA(1)==)
                             > functionBody; LA(1)=={
                              > expr; LA(1)==$
                               > exprSingle; LA(1)==$
                                > orExpr; LA(1)==$
                                 > andExpr; LA(1)==$
                                  > comparisonExpr; LA(1)==$
                                   > stringConcatExpr; LA(1)==$
                                    > rangeExpr; LA(1)==$
                                     > additiveExpr; LA(1)==$
                                      > multiplicativeExpr; LA(1)==$
                                       > unionExpr; LA(1)==$
                                        > intersectExceptExpr; LA(1)==$
                                         > instanceofExpr; LA(1)==$
                                          > treatExpr; LA(1)==$
                                           > castableExpr; LA(1)==$
                                            > castExpr; LA(1)==$
                                             > unaryExpr; LA(1)==$
                                              > valueExpr; LA(1)==$
                                               > pathExpr; LA(1)==$
                                                > relativePathExpr; LA(1)==$
                                                 > stepExpr; LA(1)==$
                                                  > postfixExpr; LA(1)==$
                                                   > primaryExpr; LA(1)==$
                                                    > varRef; LA(1)==$
                                                     > qName; LA(1)==x
                                                      > ncnameOrKeyword; [guessing]LA(1)==x
                                                      < ncnameOrKeyword; [guessing]LA(1)==}
                                                      > ncnameOrKeyword; LA(1)==x
                                                      < ncnameOrKeyword; LA(1)==}
                                                     < qName; LA(1)==}
                                                    < varRef; LA(1)==}
                                                   < primaryExpr; LA(1)==}
                                                  < postfixExpr; LA(1)==}
                                                 < stepExpr; LA(1)==}
                                                < relativePathExpr; LA(1)==}
                                               < pathExpr; LA(1)==}
                                              < valueExpr; LA(1)==}
                                             < unaryExpr; LA(1)==}
                                            < castExpr; LA(1)==}
                                           < castableExpr; LA(1)==}
                                          < treatExpr; LA(1)==}
                                         < instanceofExpr; LA(1)==}
                                        < intersectExceptExpr; LA(1)==}
                                       < unionExpr; LA(1)==}
                                      < multiplicativeExpr; LA(1)==}
                                     < additiveExpr; LA(1)==}
                                    < rangeExpr; LA(1)==}
                                   < stringConcatExpr; LA(1)==}
                                  < comparisonExpr; LA(1)==}
                                 < andExpr; LA(1)==}
                                < orExpr; LA(1)==}
                               < exprSingle; LA(1)==}
                              < expr; LA(1)==}
                             < functionBody; LA(1)==(
                            < inlineFunctionExpr; LA(1)==(
                           < functionItemExpr; LA(1)==(
                          < primaryExpr; LA(1)==(
                          > dynamicFunCall; LA(1)==(
                           > argumentList; LA(1)==(
                            > argument; LA(1)==hello
                             > exprSingle; LA(1)==hello
                              > orExpr; LA(1)==hello
                               > andExpr; LA(1)==hello
                                > comparisonExpr; LA(1)==hello
                                 > stringConcatExpr; LA(1)==hello
                                  > rangeExpr; LA(1)==hello
                                   > additiveExpr; LA(1)==hello
                                    > multiplicativeExpr; LA(1)==hello
                                     > unionExpr; LA(1)==hello
                                      > intersectExceptExpr; LA(1)==hello
                                       > instanceofExpr; LA(1)==hello
                                        > treatExpr; LA(1)==hello
                                         > castableExpr; LA(1)==hello
                                          > castExpr; LA(1)==hello
                                           > unaryExpr; LA(1)==hello
                                            > valueExpr; LA(1)==hello
                                             > pathExpr; LA(1)==hello
                                              > relativePathExpr; LA(1)==hello
                                               > stepExpr; LA(1)==hello
                                                > literal; [guessing]LA(1)==hello
                                                < literal; [guessing]LA(1)==)
                                                > postfixExpr; LA(1)==hello
                                                 > primaryExpr; LA(1)==hello
                                                  > eqName; [guessing]LA(1)==hello
                                                   > uriQualifiedName; [guessing]LA(1)==hello
                                                   < uriQualifiedName; [guessing]LA(1)==)
                                                  < eqName; [guessing]LA(1)==)
                                                  > literal; LA(1)==hello
                                                  < literal; LA(1)==)
                                                 < primaryExpr; LA(1)==)
                                                < postfixExpr; LA(1)==)
                                               < stepExpr; LA(1)==)
                                              < relativePathExpr; LA(1)==)
                                             < pathExpr; LA(1)==)
                                            < valueExpr; LA(1)==)
                                           < unaryExpr; LA(1)==)
                                          < castExpr; LA(1)==)
                                         < castableExpr; LA(1)==)
                                        < treatExpr; LA(1)==)
                                       < instanceofExpr; LA(1)==)
                                      < intersectExceptExpr; LA(1)==)
                                     < unionExpr; LA(1)==)
                                    < multiplicativeExpr; LA(1)==)
                                   < additiveExpr; LA(1)==)
                                  < rangeExpr; LA(1)==)
                                 < stringConcatExpr; LA(1)==)
                                < comparisonExpr; LA(1)==)
                               < andExpr; LA(1)==)
                              < orExpr; LA(1)==)
                             < exprSingle; LA(1)==)
                            < argument; LA(1)==)
                           < argumentList; LA(1)==null
                          < dynamicFunCall; LA(1)==null
                         < postfixExpr; LA(1)==null
                        < stepExpr; LA(1)==null
                       < relativePathExpr; LA(1)==null
                      < pathExpr; LA(1)==null
                     < valueExpr; LA(1)==null
                    < unaryExpr; LA(1)==null
                   < castExpr; LA(1)==null
                  < castableExpr; LA(1)==null
                 < treatExpr; LA(1)==null
                < instanceofExpr; LA(1)==null
               < intersectExceptExpr; LA(1)==null
              < unionExpr; LA(1)==null
             < multiplicativeExpr; LA(1)==null
            < additiveExpr; LA(1)==null
           < rangeExpr; LA(1)==null
          < stringConcatExpr; LA(1)==null
         < comparisonExpr; LA(1)==null
        < andExpr; LA(1)==null
       < orExpr; LA(1)==null
      < exprSingle; LA(1)==null
     < expr; LA(1)==null
    < queryBody; LA(1)==null
   < mainModule; LA(1)==null
  < module; LA(1)==null
 < xpath; LA(1)==null
```

and the trace of the XQuery Tree parse looks like:

```
> xpath(null)
  > module(null)
   > mainModule(null)
    > prolog(null)
     > functionDecl(null)
      > annotations(x)
      < annotations(x)
      > paramList(x)
       > param(x)
       < param({)
      < paramList({)
      > expr(x)
       > primaryExpr(x)
        > postfixExpr(null)
        < postfixExpr(<ASTNULL>)
       < primaryExpr(<ASTNULL>)
      < expr(<ASTNULL>)
     < functionDecl(DynamicFunction)
    < prolog(DynamicFunction)
    > expr(DynamicFunction)
    < expr(DynamicFunction)
   < mainModule(DynamicFunction)
  < module(null)
 < xpath(null)
```
