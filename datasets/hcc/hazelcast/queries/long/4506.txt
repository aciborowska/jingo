Profiling a Hazelcast app reveals thread contention in SpringManagedContext on java.lang.Class.getAnnotation(). That calls a synchronized method called java.lang.Class.initAnnotationsIfNecessary(). Stack trace is:

```
java.lang.Class.initAnnotationsIfNecessary()
   java.lang.Class.getAnnotation(Class)
      com.hazelcast.spring.context.SpringManagedContext.initializeIfSpringAwareIsPresent(Object)
         com.hazelcast.spring.context.SpringManagedContext.initialize(Object)
            com.hazelcast.instance.HazelcastManagedContext.initialize(Object)
               com.hazelcast.nio.serialization.SerializationServiceImpl.toObject(Object)
                  com.hazelcast.map.operation.QueryOperation$PartitionCallable.call()
                     com.hazelcast.map.operation.QueryOperation$PartitionCallable.call()
                        java.util.concurrent.FutureTask.run()
                           com.hazelcast.util.executor.CompletableFutureTask.run()
                              com.hazelcast.util.executor.CachedExecutorServiceDelegate$Worker.run()
                                 java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor$Worker)
                                    java.util.concurrent.ThreadPoolExecutor$Worker.run()
                                       java.lang.Thread.run()
                                          com.hazelcast.util.executor.PoolExecutorThreadFactory$ManagedThread.run()
```

A way of preventing this is to cache the results of getAnnotation, so that it is only called once per class. Instead, it's called on every object deserialization (along with other places.) Performance could be improved.
