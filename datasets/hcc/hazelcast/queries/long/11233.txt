Check the arrow below. The original exception isn't attached as cause, so we are loosing very important data!

```
 public void notifyException(Throwable exception) {
        if (!lifecycleService.isRunning()) {
            clientInvocationFuture.complete(new HazelcastClientNotActiveException(exception.getMessage(), exception));
            return;
        }

        if (isNotAllowedToRetryOnSelection(exception)) {
            clientInvocationFuture.complete(exception);
            return;
        }

        boolean retry = isRetrySafeException(exception)
                || invocationService.isRedoOperation()
                || (exception instanceof TargetDisconnectedException && clientMessage.isRetryable());
        if (!retry) {
            clientInvocationFuture.complete(exception);
            return;
        }

        long remainingMillis = retryExpirationMillis - System.currentTimeMillis();
        if (remainingMillis < 0) {
            if (logger.isFinestEnabled()) {
                logger.finest("Exception will not be retried because invocation timed out", exception);
            }
            clientInvocationFuture.complete(new OperationTimeoutException(this + " timed out by "
                    + Math.abs(remainingMillis) + " ms"));<--------------
            return;
        }

        try {
            executionService.schedule(this, RETRY_WAIT_TIME_IN_SECONDS, TimeUnit.SECONDS);
        } catch (RejectedExecutionException e) {
            clientInvocationFuture.complete(exception);
        }

    }
```