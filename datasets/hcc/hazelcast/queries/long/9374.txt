we are sporadically experiencing TransactionException: Transaction couldn't obtain lock for the key, while calling TransactionalMap.getForUpdate().

What is sad that the cluster itself looks normal, no exceptions in the logs, and on the client side we have no idea how to handle this exception. Is this partition corruption, data issue...
How as a client we can rely on datastore throwing such generic exceptions...

could you please explain what conditions are leading to this exception? what should be done / best practices dealing with transactions to avoid this situation? Should we retry the request?
how else we can handle this exception?

from the source of TransactionalMapProxySupport:270
```
            versionedValue = future.get();
            if (versionedValue == null) {
                throw new TransactionException("Transaction couldn't obtain lock for the key: " + toObjectIfNeeded(key));
            }
```
what does this check for null mean? was the value deleted while trying to obtain the lock?



```
Caused by: com.hazelcast.transaction.TransactionException: Transaction couldn't obtain lock for the key: HeapData{type=-11, hashCode=-1540458485, partitionHash=-1540458485, totalSize=48, dataSize=40, heapCost=68}
	at com.hazelcast.map.impl.tx.TransactionalMapProxySupport.lockAndGet(TransactionalMapProxySupport.java:270) ~[hazelcast-3.6.5.jar:3.6.5]
	at com.hazelcast.map.impl.tx.TransactionalMapProxySupport.getForUpdateInternal(TransactionalMapProxySupport.java:117) ~[hazelcast-3.6.5.jar:3.6.5]
	at com.hazelcast.map.impl.tx.TransactionalMapProxy.getForUpdate(TransactionalMapProxy.java:124) ~[hazelcast-3.6.5.jar:3.6.5]
	at com.hazelcast.client.impl.protocol.task.transactionalmap.TransactionalMapGetForUpdateMessageTask.innerCall(TransactionalMapGetForUpdateMessageTask.java:43) ~[hazelcast-3.6.5.jar:3.6.5]
	at com.hazelcast.client.impl.protocol.task.AbstractTransactionalMessageTask.call(AbstractTransactionalMessageTask.java:34) ~[hazelcast-3.6.5.jar:3.6.5]
	at com.hazelcast.client.impl.protocol.task.AbstractCallableMessageTask.processMessage(AbstractCallableMessageTask.java:34) ~[hazelcast-3.6.5.jar:3.6.5]
	at com.hazelcast.client.impl.protocol.task.AbstractMessageTask.initializeAndProcessMessage(AbstractMessageTask.java:118) ~[hazelcast-3.6.5.jar:3.6.5]
	at com.hazelcast.client.impl.protocol.task.AbstractMessageTask.run(AbstractMessageTask.java:98) ~[hazelcast-3.6.5.jar:3.6.5]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[na:1.8.0_101]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_101]
	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_101]
	at com.hazelcast.util.executor.HazelcastManagedThread.executeRun(HazelcastManagedThread.java:76) ~[hazelcast-3.6.5.jar:3.6.5]
	at com.hazelcast.util.executor.HazelcastManagedThread.run(HazelcastManagedThread.java:92) ~[hazelcast-3.6.5.jar:3.6.5]
	at ------ End remote and begin local stack-trace ------.(Unknown Source) ~[na:na]
	at com.hazelcast.client.spi.impl.ClientInvocationFuture.resolveResponse(ClientInvocationFuture.java:128) ~[hazelcast-client-3.6.5.jar:3.6.5]
	at com.hazelcast.client.spi.impl.ClientInvocationFuture.get(ClientInvocationFuture.java:95) ~[hazelcast-client-3.6.5.jar:3.6.5]
	at com.hazelcast.client.spi.impl.ClientInvocationFuture.get(ClientInvocationFuture.java:74) ~[hazelcast-client-3.6.5.jar:3.6.5]
	at com.hazelcast.client.spi.impl.ClientInvocationFuture.get(ClientInvocationFuture.java:37) ~[hazelcast-client-3.6.5.jar:3.6.5]
	at com.hazelcast.client.proxy.txn.ClientTxnProxy.invoke(ClientTxnProxy.java:48) ~[hazelcast-client-3.6.5.jar:3.6.5]
	at com.hazelcast.client.proxy.txn.ClientTxnMapProxy.getForUpdate(ClientTxnMapProxy.java:81) ~[hazelcast-client-3.6.5.jar:3.6.5]
```