This is related to issue #223. In the test program https://gist.github.com/3245858, each node has
1. A putter thread which puts values to the key at random intervals.
2. A remover thread which removes values of the key at random intervals.
Both have lock() or tryLock() and unlock around the operations.

The putter threads in all nodes are expected to keep printing an incremental count during run. An execution of the test reveals that after a while, the putter thread in one node is blocked forever by lock(). The putter thread in another node runs as usual, showing that the lock can be released.

Below is the stack trace of the blocked thread shown in JConsole:

Name: Thread-2
State: TIMED_WAITING on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@815a3a1
Total blocked: 2  Total waited: 1,380

Stack trace: 
sun.misc.Unsafe.park(Native Method)
java.util.concurrent.locks.LockSupport.parkNanos(Unknown Source)
java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(Unknown Source)
com.hazelcast.util.ResponseQueueFactory$LockBasedResponseQueue.poll(ResponseQueueFactory.java:63)
com.hazelcast.impl.BaseManager$ResponseQueueCall.waitAndGetResult(BaseManager.java:550)
com.hazelcast.impl.BaseManager$ResponseQueueCall.getRedoAwareResult(BaseManager.java:579)
com.hazelcast.impl.BaseManager$ResponseQueueCall.getResult(BaseManager.java:574)
com.hazelcast.impl.BaseManager$RequestBasedCall.getResultAsObject(BaseManager.java:421)
com.hazelcast.impl.BaseManager$ResponseQueueCall.getResultAsObject(BaseManager.java:510)
com.hazelcast.impl.BaseManager$RequestBasedCall.getResultAsObject(BaseManager.java:417)
com.hazelcast.impl.BaseManager$ResponseQueueCall.getResultAsObject(BaseManager.java:510)
com.hazelcast.impl.ConcurrentMapManager$MLock.lock(ConcurrentMapManager.java:489)
com.hazelcast.impl.ConcurrentMapManager$MLock.lock(ConcurrentMapManager.java:472)
com.hazelcast.impl.ConcurrentMapManager.lock(ConcurrentMapManager.java:403)
com.hazelcast.impl.MProxyImpl$MProxyReal.lock(MProxyImpl.java:683)
sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)
sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
java.lang.reflect.Method.invoke(Unknown Source)
com.hazelcast.impl.MProxyImpl$DynamicInvoker.invoke(MProxyImpl.java:66)
$Proxy0.lock(Unknown Source)
com.hazelcast.impl.MProxyImpl.lock(MProxyImpl.java:389)
com.hazelcast.impl.MultiMapProxyImpl$MultiMapReal.lock(MultiMapProxyImpl.java:327)
com.hazelcast.impl.MultiMapProxyImpl.lock(MultiMapProxyImpl.java:193)
mm.Putter.run(Putter.java:30)
java.lang.Thread.run(Unknown Source)
