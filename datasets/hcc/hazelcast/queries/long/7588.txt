I wanted to check for object existence before calling getForUpdate().
Reason: hazelcast lockAndGet() (invoked from getForUpdate()) throws too generic TransactionException("Transaction couldn't obtain lock for the key") in case of failing to lock non-existing object, which is confusing, and hard to distinguish from important TransactionExceptions

```
    private V getByKey(TransactionalMap<String, V> region, String key) {
        return region.containsKey(key) ? region.getForUpdate(key) : null;
    }
```

however, the problem is that if the key is already locked by previous getForUpdate() then 
containsKey() method blocks.

I think this is erroneous behavior as containsKey() is a read-only operation that should not be blocked.
It doesn't matter if its result comes from inside or outside of transaction.

Please, advise of what is the right way to check for object existence before getForUpdate().
(Of course it would be great for lockAndGet to return some meaningful exception in case of object not found)

tried on v3.5.5
