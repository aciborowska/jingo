As a part of https://github.com/hazelcast/hazelcast/issues/16311 (https://github.com/hazelcast/hazelcast/pull/16367) we added a check which ensures that an index which is not fully built is never used. It seems that we missed an important inconsistency between `IndexAwarePredicate.isIndexed` and `IndexAwarePredicate.filter` methods: both methods should double-check that the index is indeed usable, which is not the case at the moment.

For example, take a look at `CompositeEqualPredicate.isIndexed` - it always returns true, so we proceed to `filter` quickly, only to get NPE for the not fully built index, because `QueryContext.matchIndex` will return `null`.

We discussed possible solutions with @petrpleshachkov, and it seems that the correct fix should be as follows:
1) Remove `isIndexed` method, as it is not needed.
2) Make sure that all implementations of `IndexAwarePredicate.filter` perform proper null-checks when asking for index. Composite predicates ("and", "or", etc) should return `null` as soon as `null` is returned instead of an index.
3) Add more checks to `IndexConcurrencyTest` with different predicate types and different index types to ensure that the fix works.

Note that this should be fixed in 4.0 because otherwise, users may get NPE on not fully built indexes (previous behavior was incorrect query results).