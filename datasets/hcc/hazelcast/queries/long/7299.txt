Hi,

it looks as if the IdGenerator may generate duplicate IDs if put under stress.

Here is a test to reproduce the issue. I tested it on a 3.5.5-SNAPSHOT from 2015-12-17.

Best,
Lukas

``` java
package com.nm.test.hazelcast.idgenerator;

import com.hazelcast.config.Config;
import com.hazelcast.config.XmlConfigBuilder;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IdGenerator;
import com.nm.test.hazelcast.TestHazelcast;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import junit.framework.TestCase;

/**
 * A test to ensure the ID generator does not produce duplicate IDs.
 */
public class TestIdGenerator1 extends TestCase {

    private static final Logger logger = Logger.getLogger(TestIdGenerator1.class);

    private static final String idGeneratorName = "idGen_" + TestIdGenerator1.class.getSimpleName();

    private static final int numThreads = 16;

    private static final int numIdsPerThread = 400001;

    @Override
    protected void setUp() throws Exception {

        // configure logging
        if (!TestHazelcast.loggingInitialized) {
            TestHazelcast.loggingInitialized = true;
            BasicConfigurator.configure();
        }
    }

    public void testConcurrentIdGenMulti() throws Exception {
        final int numRuns = 5;
        int numFailures = 0;
        for (int i = 0; i < numRuns; i++) {
            if (!testConcurrentIdGen(i)) {
                numFailures++;
            }
        }
        if (numFailures > 0) {
            fail("Duplicate IDs were generated in " + numFailures + " out of " + numRuns + " runs.");
        }
    }

    private boolean testConcurrentIdGen(int runIndex) throws Exception {

        // result
        final Set<Long> generatedIds = Collections.newSetFromMap(new ConcurrentHashMap<Long, Boolean>());

        // try-finally to terminate hazelcast instance
        HazelcastInstance hcInstance = null;
        try {

            // create config
            Config config = new XmlConfigBuilder().build();
            config.setProperty("hazelcast.logging.type", "log4j");
            config.setProperty("hazelcast.version.check.enabled", "false");

            // disable multicast for faster startup
            config.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);

            // create hazelcast instance
            hcInstance = Hazelcast.newHazelcastInstance(config);

            // get and init ID generator
            final IdGenerator idGen = hcInstance.getIdGenerator(idGeneratorName + runIndex);
            idGen.init(13013L);

            // run with multiple threads in parallel
            List<Thread> threads = new ArrayList<Thread>();
            for (int threadIndex = 0; threadIndex < numThreads; threadIndex++) {
                final int threadIndexCur = threadIndex;

                Thread thread = new Thread(new Runnable() {

                    @Override
                    public void run() {

                        // generate IDs
                        logger.info("Thread " + threadIndexCur + " generating IDs...");
                        for (int i = 0; i < numIdsPerThread; i++) {
                            long newId = idGen.newId();
                            if (!generatedIds.add(newId)) {
                                logger.warn("Same ID generated: " + newId);
                            }
                        }
                        logger.info("Thread " + threadIndexCur + " generating IDs done.");
                    }

                }, "generator-thread-" + threadIndex);
                threads.add(thread);
            }

            // start and join
            for (Thread thread : threads) {
                thread.start();
            }
            for (Thread thread : threads) {
                thread.join();
            }
        } finally {
            if (hcInstance != null) {
                hcInstance.getLifecycleService().terminate();
            }
        }

        // ensure correct result
        long maxId = -1L;
        for (Long value : generatedIds) {
            if (value > maxId) {
                maxId = value;
            }
        }
        logger.info("Max ID = " + maxId);
        logger.info("Number of generated IDs = " + generatedIds.size());
        if (generatedIds.size() == numThreads * numIdsPerThread) {
            return true;
        } else {
            logger.warn("Same IDs generated!");
            return false;
        }
    }

}
```
