<!--
Thanks for reporting your issue. Please share with us the following information, to help us resolve your issue quickly and efficiently.
-->

**Describe the bug**

To work around some issues I was having with nullable Portable fields, I tried to explicitly register class definitions, following the documentation. This went well until I tried registering some classes for a second PortableFactory, that are using classIds that overlap with those of the first PortableFactory. As far as I understood from the documentation, classIds only need to be unique per PortableFactory. I then got the following exception:

```
Exception in thread "main" com.hazelcast.nio.serialization.HazelcastSerializationException: Duplicate registration found for class-id[1]!
	at com.hazelcast.internal.serialization.impl.SerializationServiceV1.registerClassDefinitions(SerializationServiceV1.java:191)
	at com.hazelcast.internal.serialization.impl.DefaultSerializationServiceBuilder.createSerializationService(DefaultSerializationServiceBuilder.java:300)
	at com.hazelcast.internal.serialization.impl.DefaultSerializationServiceBuilder.build(DefaultSerializationServiceBuilder.java:237)
	at com.hazelcast.internal.serialization.impl.DefaultSerializationServiceBuilder.build(DefaultSerializationServiceBuilder.java:55)
	at com.hazelcast.instance.DefaultNodeExtension.createSerializationService(DefaultNodeExtension.java:210)
	at com.hazelcast.instance.Node.<init>(Node.java:240)
	at com.hazelcast.instance.HazelcastInstanceImpl.createNode(HazelcastInstanceImpl.java:161)
	at com.hazelcast.instance.HazelcastInstanceImpl.<init>(HazelcastInstanceImpl.java:131)
	at com.hazelcast.instance.HazelcastInstanceFactory.constructHazelcastInstance(HazelcastInstanceFactory.java:229)
	at com.hazelcast.instance.HazelcastInstanceFactory.newHazelcastInstance(HazelcastInstanceFactory.java:208)
	at com.hazelcast.instance.HazelcastInstanceFactory.newHazelcastInstance(HazelcastInstanceFactory.java:158)
	at com.hazelcast.core.Hazelcast.newHazelcastInstance(Hazelcast.java:57)
	at eu.sensara.procare.residentstate.TestCase.main(TestCase.java:120)
```

**Expected behavior**
As described in the javadoc of Portable.getClassId(), I expected classIds to only be unique per PortableFactory, I expected no exception:

```
Returns class identifier for this portable class. Class ID should be unique per PortableFactory.
```

**To Reproduce**

I've reproduced the issue in this self-contained test case:

```
public class TestCase {

    public static class MyPortable1 implements Portable {

        public static final int ID = 1;

        private String stringField;

        @Override
        public int getFactoryId() {
            return MyPortableFactory1.ID;
        }

        @Override
        public int getClassId() {
            return ID;
        }

        @Override
        public void writePortable(final PortableWriter writer) throws IOException {
            writer.writeUTF("stringField", stringField);
        }

        @Override
        public void readPortable(final PortableReader reader) throws IOException {
            stringField = reader.readUTF("stringField");
        }

        public static ClassDefinition getClassDefinition() {
            return new ClassDefinitionBuilder(MyPortableFactory1.ID, ID)
                    .addUTFField("stringField")
                    .build();
        }

    }

    public static class MyPortable2 implements Portable {

        public static final int ID = 1;

        private int intField;

        @Override
        public int getFactoryId() {
            return MyPortableFactory2.ID;
        }

        @Override
        public int getClassId() {
            return ID;
        }

        @Override
        public void writePortable(final PortableWriter writer) throws IOException {
            writer.writeInt("intField", intField);
        }

        @Override
        public void readPortable(final PortableReader reader) throws IOException {
            intField = reader.readInt("intField");
        }

        public static ClassDefinition getClassDefinition() {
            return new ClassDefinitionBuilder(MyPortableFactory1.ID, ID)
                    .addIntField("intField")
                    .build();
        }

    }

    public static class MyPortableFactory1 implements PortableFactory {

        public static final int ID = 1;

        @Override
        public Portable create(final int classId) {
            if (classId == MyPortable1.ID) {
                return new MyPortable1();
            }
            return null;
        }

    }

    public static class MyPortableFactory2 implements PortableFactory {

        public static final int ID = 2;

        @Override
        public Portable create(final int classId) {
            if (classId == MyPortable2.ID) {
                return new MyPortable2();
            }
            return null;
        }

    }

    public static void main(final String[] args) {
        Config cfg = new Config();
        cfg.getSerializationConfig()
                .addPortableFactory(MyPortableFactory1.ID, new MyPortableFactory1())
                .addPortableFactory(MyPortableFactory2.ID, new MyPortableFactory2())
                .addClassDefinition(MyPortable1.getClassDefinition())
                .addClassDefinition(MyPortable2.getClassDefinition());
        HazelcastInstance hazelcast = Hazelcast.newHazelcastInstance(cfg);
    }

}
```

**Additional context**

I've produced this issue with Hazelcast version 3.12.6, on openjdk 11.0.6.

It seems like SerializationServiceV1 creates a single HashMap that is then filled with all class definitions (of all PortableFactories), using the classId as the key. The result is that it encounters the same key for a second time and throws the HazelcastSerializationException.

I hope I am reading the documentation correctly. I was not able to find anything specifying this as a known limitation of explictly registering ClassDefinitions.