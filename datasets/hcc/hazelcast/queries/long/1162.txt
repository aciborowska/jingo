Hazelcast 3.1.1
When executing a remote operation, Hazelcast needs to load the needed classes from their designated ClassLoader.
This is fine, however shows significant contention and CPU-load depending upon the involved ClassLoaders.
Symptoms are threads like the one below, plus additional blocked threads waiting for this one in combination with high CPU-load due to the repeated Class look-ups.

```
hz.PE2.cached.thread-13 - RUNNABLE
      (...)
      at org.jboss.modules.ConcurrentClassLoader.loadClass(ConcurrentClassLoader.java:133)
      at java.lang.ClassLoader.loadClass(ClassLoader.java:412)
      at java.lang.ClassLoader.loadClass(ClassLoader.java:358)
      at com.hazelcast.nio.ClassLoaderUtil.loadClass(ClassLoaderUtil.java:83)
      at com.hazelcast.nio.IOUtil$1.resolveClass(IOUtil.java:77)
      at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1612)
      (...)
      at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370)
      at com.hazelcast.nio.serialization.DefaultSerializers$ObjectSerializer.read(DefaultSerializers.java:185)
      at com.hazelcast.nio.serialization.StreamSerializerAdapter.read(StreamSerializerAdapter.java:40)
      at com.hazelcast.nio.serialization.SerializationServiceImpl.readObject(SerializationServiceImpl.java:271)
      at com.hazelcast.nio.serialization.ByteArrayObjectDataInput.readObject(ByteArrayObjectDataInput.java:431)
      at com.hazelcast.executor.BaseCallableTaskOperation.readInternal(BaseCallableTaskOperation.java:91)
      at com.hazelcast.spi.Operation.readData(Operation.java:295)
      at com.hazelcast.nio.serialization.DataSerializer.read(DataSerializer.java:105)
      at com.hazelcast.nio.serialization.DataSerializer.read(DataSerializer.java:36)
      at com.hazelcast.nio.serialization.StreamSerializerAdapter.read(StreamSerializerAdapter.java:59)
      at com.hazelcast.nio.serialization.SerializationServiceImpl.toObject(SerializationServiceImpl.java:213)
      at com.hazelcast.spi.impl.NodeEngineImpl.toObject(NodeEngineImpl.java:156)
      at com.hazelcast.spi.impl.OperationServiceImpl$RemoteOperationProcessor.run(OperationServiceImpl.java:728)
      at com.hazelcast.util.executor.ManagedExecutorService$Worker.run(ManagedExecutorService.java:166)
      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
      at java.lang.Thread.run(Thread.java:744)
      at com.hazelcast.util.executor.PoolExecutorThreadFactory$ManagedThread.run(PoolExecutorThreadFactory.java:59)
```

Despite you may argue, that this should be the ClassLoader's responsibility, this could be enhanced on Hazelcast's ClassLoaderUtil to make it independent of possibly single-threaded and/or slow ClassLoaders.

The following is a proposal, which caches already known Classes, but only by using SoftReferences, thus adding nearly no memory-overhead. It works and shows a significant lower CPU-load and no-more contention in my tests in this area. I strived away from using some limited self-reorganizing Collection like from guava, to keep it simple and only using core Java API.
Comments welcome, please give it some though, if sth. like this makes sense to include in general.
If you like, I can also send this as a PR.

``` Diff
diff --git a/hazelcast/src/main/java/com/hazelcast/nio/ClassLoaderUtil.java b/hazelcast/src/main/java/com/hazelcast/nio/ClassLoaderUtil.java
index 69e052f..eaba556 100644
--- a/hazelcast/src/main/java/com/hazelcast/nio/ClassLoaderUtil.java
+++ b/hazelcast/src/main/java/com/hazelcast/nio/ClassLoaderUtil.java
@@ -16,10 +16,21 @@

 package com.hazelcast.nio;

+import java.io.Serializable;
+import java.lang.ref.Reference;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.SoftReference;
 import java.lang.reflect.Constructor;
+import java.util.AbstractMap;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.LinkedHashSet;
 import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import com.hazelcast.logging.ILogger;
+import com.hazelcast.logging.Logger;

 /**
  * @author mdogan 4/12/12
@@ -31,6 +42,15 @@

     private static final Map<String, Class> PRIMITIVE_CLASSES;
     private static final int MAX_PRIM_CLASSNAME_LENGTH = 7; // boolean.class.getName().length();
+
+    private static final ILogger logger = Logger.getLogger(ClassLoaderUtil.class);
+
+    /**
+     * Class cache. Using soft references to not hinder GC.
+     * No upper limits, but should not be a problem,
+     * since we only add some {@link SoftReference} objects to the already existing memory usage.
+     */
+    private static final Map<ClassCachePK, Class<?>> classCache = new SoftConcurrentHashMap<ClassCachePK, Class<?>>();

     static {
         final Map<String, Class> primitives = new HashMap<String, Class>(10, 1.0f);
@@ -78,12 +98,15 @@
         }
         if (theClassLoader != null) {
             if (className.startsWith("[")) {
-                return Class.forName(className, true, theClassLoader);
+                return cacheLoad(className, true, theClassLoader);
             } else {
-                return theClassLoader.loadClass(className);
+                return cacheLoad(className, false, theClassLoader);
             }
         }
-        return Class.forName(className);
+        return cacheLoad(className, true, ClassLoaderUtil.class.getClassLoader());
     }

     public static boolean isInternalType(Class type) {
@@ -91,5 +114,297 @@
             && type.getName().startsWith(HAZELCAST_BASE_PACKAGE);
     }

+    /**
+     * Gets {@link Class} from cache or loads it and and puts it into cache for subsequent look-ups.
+     *
+     * @param className
+     * @param forName whether to use {@link Class#forName(String, boolean, ClassLoader)} (true) or
+     *      {@link ClassLoader#loadClass(String)} (false).
+     * @param classLoader
+     * @return loaded {@link Class}
+     * @throws ClassNotFoundException
+     */
+    private static Class<?> cacheLoad(String className, boolean forName, ClassLoader classLoader)
+            throws ClassNotFoundException {
+        assert className != null;
+        assert classLoader != null;
+
+        final boolean finestEnabled = logger.isFinestEnabled();
+
+        final ClassCachePK classCachePK = new ClassCachePK(className, classLoader);
+
+        Class<?> cachedClass = classCache.get(classCachePK);
+        if (cachedClass != null) {
+            if (finestEnabled) {
+                logger.finest("Found class in cache " + className + ". PK=" + classCachePK);
+            }
+            return cachedClass;
+        }
+
+        // cache miss
+        final Class<?> loadedClass;
+        if (forName)
+        {
+            loadedClass = Class.forName(className, true, classLoader);
+        }
+        else
+        {
+            loadedClass = classLoader.loadClass(className);
+        }
+
+        Class<?> prevousClass = classCache.put(classCachePK, loadedClass);
+        if (finestEnabled) {
+            if (prevousClass != null) {
+                // may also occur if class is added first time due to concurrent calls. But better than synchronizing.
+                logger.finest("Replaced cached class " + className + " with new one. Size=" + classCache.size() + ". PK=" + classCachePK);
+            }
+            else
+            {
+                logger.finest("Added class to cache " + className + ". Size=" + classCache.size() + ". PK=" + classCachePK);
+            }
+        }
+
+        return loadedClass;
+    }
+
     private ClassLoaderUtil() {}
+
+
+    /**
+     * ClassCachePK.
+     * {@link ClassLoader} does not redefine equals and hashCode, so this may have some potential issues,
+     * but usually it works fine and
+     * but best way to map a {@link Class} to its class name / {@link ClassLoader} combination.
+     *
+     * @author Rico Neubauer
+     */
+    protected static class ClassCachePK {
+
+        private final String className;
+        private final ClassLoader classLoader;
+
+        public ClassCachePK(String className, ClassLoader classLoader) {
+            this.className = className;
+            this.classLoader = classLoader;
+        }
+
+        /**
+         * @see java.lang.Object#hashCode()
+         */
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + ((classLoader == null) ? 0 : classLoader.hashCode());
+            result = prime * result + ((className == null) ? 0 : className.hashCode());
+            return result;
+        }
+
+        /**
+         * @see java.lang.Object#equals(java.lang.Object)
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (obj == null)
+                return false;
+            if (getClass() != obj.getClass())
+                return false;
+            ClassCachePK other = (ClassCachePK)obj;
+            if (classLoader == null) {
+                if (other.classLoader != null)
+                    return false;
+            }
+            else if (!classLoader.equals(other.classLoader))
+                return false;
+            if (className == null) {
+                if (other.className != null)
+                    return false;
+            }
+            else if (!className.equals(other.className))
+                return false;
+            return true;
+        }
+
+        /**
+         * @see java.lang.Object#toString()
+         */
+        @Override
+        public String toString() {
+            StringBuilder builder = new StringBuilder();
+            builder.append("ClassCachePK [className=");
+            builder.append(className);
+            builder.append(", classLoader=");
+            builder.append(classLoader);
+            builder.append("]");
+            return builder.toString();
+        }
+
+    }
+
+
+    /**
+     * SoftConcurrentHashMap.
+     * You can use the SoftConcurrentHashMap just like an ordinary HashMap,
+     * except that the entries will disappear if we are running low on memory.
+     * Ideal if you want to build a cache.
+     *
+     * This implementation <b>is</b> thread-safe (just like {@link ConcurrentHashMap}).
+     * This class does <b>not</b> allow null to be used as a key or value.
+     *
+     * Inspired by http://www.javaspecialists.eu/archive/Issue098.html
+     *
+     * @author Rico Neubauer
+     * @since 27.04.2010
+     */
+    protected static class SoftConcurrentHashMap<K, V> extends AbstractMap<K, V> implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        /** The internal HashMap that will hold the SoftReference. */
+        private final Map<K, SoftReference<V>> hash = new ConcurrentHashMap<K, SoftReference<V>>();
+
+        private final Map<SoftReference<V>, K> reverseLookup = new ConcurrentHashMap<SoftReference<V>, K>();
+
+        /** Reference queue for cleared SoftReference objects. */
+        protected final ReferenceQueue<V> queue = new ReferenceQueue<V>();
+
+
+        @Override
+        public V get(Object key)
+        {
+            expungeStaleEntries();
+            V result = null;
+            // We get the SoftReference represented by that key
+            final SoftReference<V> soft_ref = hash.get(key);
+            if (soft_ref != null)
+            {
+                // From the SoftReference we get the value, which can be
+                // null if it has been garbage collected
+                result = soft_ref.get();
+                if (result == null)
+                {
+                    // If the value has been garbage collected, remove the
+                    // entry from the HashMap.
+                    hash.remove(key);
+                    reverseLookup.remove(soft_ref);
+                }
+            }
+            return result;
+        }
+
+
+        private void expungeStaleEntries()
+        {
+            Reference<? extends V> sv;
+            while ((sv = queue.poll()) != null)
+            {
+                final K removed = reverseLookup.remove(sv);
+                if (removed != null)
+                {
+                    hash.remove(removed);
+                }
+            }
+        }
+
+
+        @Override
+        public V put(K key, V value)
+        {
+            expungeStaleEntries();
+            final SoftReference<V> soft_ref = new SoftReference<V>(value, queue);
+            final SoftReference<V> oldSoftRef = hash.put(key, soft_ref);
+            reverseLookup.put(soft_ref, key);
+            if (oldSoftRef == null)
+            {
+                return null;
+            }
+            reverseLookup.remove(oldSoftRef);
+            return oldSoftRef.get();
+        }
+
+
+        @Override
+        public V remove(Object key)
+        {
+            expungeStaleEntries();
+            final SoftReference<V> softRef = hash.remove(key);
+            // small concurrency gap - reverseLookup still holds entry
+            if (softRef == null)
+            {
+                return null;
+            }
+            reverseLookup.remove(softRef);
+            return softRef.get();
+        }
+
+
+        @Override
+        public void clear()
+        {
+            hash.clear();
+            reverseLookup.clear();
+        }
+
+
+        @Override
+        public int size()
+        {
+            expungeStaleEntries();
+            return hash.size();
+        }
+
+
+        /**
+         * Returns a copy of the key/values in the map at the point of calling.
+         * However, setValue still sets the value in the actual SoftHashMap.
+         *
+         * @return a copy of the key/values in the map at the point of calling.
+         * @see java.util.AbstractMap#entrySet()
+         * @inheritDoc
+         */
+        @Override
+        public Set<Entry<K, V>> entrySet()
+        {
+            expungeStaleEntries();
+            final Set<Entry<K, V>> result = new LinkedHashSet<Entry<K, V>>();
+            for (final Entry<K, SoftReference<V>> entry : hash.entrySet())
+            {
+                final V value = entry.getValue().get();
+                if (value != null)
+                {
+                    result.add(new Entry<K, V>()
+                    {
+                        @Override
+                        public K getKey()
+                        {
+                            return entry.getKey();
+                        }
+
+
+                        @Override
+                        public V getValue()
+                        {
+                            return value;
+                        }
+
+
+                        @Override
+                        public V setValue(V v)
+                        {
+                            entry.setValue(new SoftReference<V>(v, queue));
+                            return value;
+                        }
+                    });
+                }
+            }
+            return result;
+        }
+    }
+
 }
```
