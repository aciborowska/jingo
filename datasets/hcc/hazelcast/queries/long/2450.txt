We are using ICondition instances to await a condition to happen before proceding doing something. Our code looks like:

```
ILock lock = hzInstance.getLock("myLock");
ICondition cond = lock.newCondition("something");

lock.lock();
try {

    while(<SOME CONDITION>) {
        cond.await(1, TimeUnit.SECONDS);
    }

}
finally {
    lock.unlock();
}
```

In another place of code we have something like:

```
ILock lock = hzInstance.getLock("myLock");
ICondition cond = lock.newCondition("something");

lock.lock();
try {
    cond.signalAll();
}
finally {
    lock.unlock();
}
```

From time to time we got:

```
19:10:47.853 [hz._hzInstance_1_test.operation.thread-4] ERROR com.hazelcast.concurrent.lock.operations.AwaitOperation - [192.168.1.100]:5701 [test] [3.2.1] null
java.lang.IllegalStateException
at com.hazelcast.concurrent.lock.ConditionInfo.startWaiter(ConditionInfo.java:61) ~[hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.concurrent.lock.LockResourceImpl.startAwaiting(LockResourceImpl.java:180) ~[hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.concurrent.lock.LockStoreImpl.startAwaiting(LockStoreImpl.java:233) ~[hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.concurrent.lock.operations.AwaitOperation.beforeRun(AwaitOperation.java:50) ~[hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.spi.impl.BasicOperationService.processOperation(BasicOperationService.java:355) [hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.spi.impl.BasicOperationService.runOperation(BasicOperationService.java:228) [hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.concurrent.lock.operations.UnlockOperation.afterRun(UnlockOperation.java:85) [hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.spi.impl.BasicOperationService.processOperation(BasicOperationService.java:389) [hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.spi.impl.BasicOperationService.access$300(BasicOperationService.java:102) [hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.spi.impl.BasicOperationService$BasicOperationProcessorImpl.process(BasicOperationService.java:754) [hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.spi.impl.BasicOperationScheduler$PartitionThread.process(BasicOperationScheduler.java:276) [hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.spi.impl.BasicOperationScheduler$PartitionThread.doRun(BasicOperationScheduler.java:270) [hazelcast-3.2.1.jar:3.2.1]
at com.hazelcast.spi.impl.BasicOperationScheduler$PartitionThread.run(BasicOperationScheduler.java:245) [hazelcast-3.2.1.jar:3.2.1]
```

It seems like await returns but lock is not acquired, so when trying to await again we got the error, but don't know for sure. We have managed a workaround to this issue by catching IllegalStateException and acquiring lock manually.

Another thing we also saw is await not returning after a signalAll call. As a workaround all our await calls have timeout.
