Consider two nodes that access the same hazelcast-Map. After creating the map an index should be added. Node one does this and starts adding objects to the map. Then node two starts up and tries to get the map and to create the index too, as it cannot be sure that this map was not already created initially by another node.

Adding an index to a map that is not empty ends up in a never returning call to map.addIndex();
This happens for me with Hazelcast 2.3.1.

Stacktrace:

<pre>
    SCHWERWIEGEND: [172.16.208.1]:5701 [dev] error processing messages  processable=com.hazelcast.impl.MProxyImpl$MProxyReal$1@65d0d124
    java.lang.RuntimeException: Index can only be added before adding entries!
    Add indexes first and only once then put entries.
        at com.hazelcast.query.MapIndexService.addIndex(MapIndexService.java:132)
        at com.hazelcast.impl.CMap.addIndex(CMap.java:428)
        at com.hazelcast.impl.concurrentmap.AddMapIndex.process(AddMapIndex.java:52)
        at com.hazelcast.impl.BaseManager.sendProcessableToAll(BaseManager.java:1243)
        at com.hazelcast.impl.MProxyImpl$MProxyReal$1.process(MProxyImpl.java:523)
        at com.hazelcast.cluster.ClusterService.processProcessable(ClusterService.java:188)
        at com.hazelcast.cluster.ClusterService.dequeueProcessables(ClusterService.java:254)
        at com.hazelcast.cluster.ClusterService.run(ClusterService.java:199)
        at java.lang.Thread.run(Thread.java:662)
    17.10.2012 18:16:15 com.hazelcast.cluster.ClusterService
    SCHWERWIEGEND: [172.16.208.1]:5701 [dev] Index can only be added before adding entries!
    Add indexes first and only once then put entries.
    java.lang.RuntimeException: Index can only be added before adding entries!
    Add indexes first and only once then put entries.
        at com.hazelcast.query.MapIndexService.addIndex(MapIndexService.java:132)
        at com.hazelcast.impl.CMap.addIndex(CMap.java:428)
        at com.hazelcast.impl.concurrentmap.AddMapIndex.process(AddMapIndex.java:52)
        at com.hazelcast.impl.BaseManager.sendProcessableToAll(BaseManager.java:1243)
        at com.hazelcast.impl.MProxyImpl$MProxyReal$1.process(MProxyImpl.java:523)
        at com.hazelcast.cluster.ClusterService.processProcessable(ClusterService.java:188)
        at com.hazelcast.cluster.ClusterService.dequeueProcessables(ClusterService.java:254)
        at com.hazelcast.cluster.ClusterService.run(ClusterService.java:199)
        at java.lang.Thread.run(Thread.java:662)
</pre>


This can be easily reproduced with a unit test:

``` java
@Test
public void testMapIndex() throws Exception {
    HazelcastInstance hazelcast = Hazelcast.getDefaultInstance();
    IMap<String, MapValue> testMap = hazelcast.getMap("testMapIndexTestMap");
    testMap.put("key1", new MapValue(1));

    testMap.addIndex("value", false);
}

private static final class MapValue implements Serializable {

    private final int value;

    public MapValue(int value) {
        super();
        this.value = value;            
    }

    public int getValue() {
        return value;
    }
}
```
