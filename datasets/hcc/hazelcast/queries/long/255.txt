HZ team,
I am making good progress on the evaluation and have come to another question on transactional map access. Would appreciate your help.

From the doc, the lock would be acquired for write operations and the isolation level is read-committed. However I am able to produce a classic dead lock condition, wondering why?

Simplified test case: 
1-member cluster maintaining a simple IMap, with String keys and simple object values.
Separate client process with 2 threads access the map concurrently.
The client is running the following 2 tasks in parallel in separate threads.
Task A:
1. client.getTransaction().begin()
2. map.get(keyA)
3. sleep(1000)
4. map.get(keyB)

Task B:
1. client.getTransaction().begin()
2. map.get(keyB)
3. sleep(1000)
4. map.get(keyA)

Deadlock occurs and both threads stuck at step 4. The cluster recovers after a 30 second timeout. However the client threads remain deadlock'ed. Is it trying to acquire an exclusive lock for the get and keep it till the end of the transaction?

Issue reproducible on both version 2.2 and 2.3.

Thanks,
Dan
