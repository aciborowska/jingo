`IQueue.take` is documented as throwing `InterruptedException` if it is interrupted while waiting, but in 3.2 it actually throws a `HazelcastException` that wraps the `InterruptedException`.

Here is a test case:

```
package hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IQueue;
import org.junit.Test;

import java.util.concurrent.Executors;

public class HazelcastTakeInterrupted
{
    @Test(expected = InterruptedException.class)
    public void test() throws InterruptedException {

        HazelcastInstance instance = Hazelcast.newHazelcastInstance();
        HazelcastInstance client = HazelcastClient.newHazelcastClient();

        final Thread mainThread = Thread.currentThread();

        Executors.newSingleThreadExecutor().execute(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {}
                mainThread.interrupt();
            }
        });

        IQueue<String> queue = client.getQueue("TestQueue");
        queue.take();
    }
}
```

It looks like `IQueue.poll` has a similar issue too.
