The attached test program reproduces that the attribute heapCost of the localMapStats of an IMap does not go down to 0 after stuff is added, read and removed, but raises and raises without limit. Debugging into Hazelcast shows that its NearCacheSizeEstimator.size is not 0.

Please notice that this causes serious problems when USED_HEAP_SIZE is used for eviction, since hazelcast also uses this estimator to calculate the maps overall size. Thus, the map will be limited to be smaller and smaller, since the estimator thinks its size is much bigger than it actually is. In our application, this repeatably causes a crash: the hibernate second level cache becomes too small after a while, causing more and more unneccesary SQL fetches for data missing in the cache, leading ultimately to the applications death.

The test program has to be started two times in parallel. It waits until a cluster of two nodes is formed, and then repeatedly fills up the IMap, reads all its contents back from a number of threads in parallel, and removes all items from the IMap with remove. Normally, the heapCost should be 0 after that, but it isn't - in my last tries it was about 600000.

I tried this with JDK 1.7.0_75 with Windows and -Xmx1024m, Windows 8, and both hazelcast 3.4.6 and 3.5.4.

[BrokenMemoryLimitHazelcast.zip](https://github.com/hazelcast/hazelcast/files/59444/BrokenMemoryLimitHazelcast.zip)
