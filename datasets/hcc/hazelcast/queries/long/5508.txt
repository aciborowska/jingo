Whereas IQueue.iterator() returns an iterator which explicitly throws an UnsupportedOperationException on iterator.remove(), in case of IList this operation is simply a NOOP.
One can call iterator.remove(), but it doesn't do anything.
A look in the code (ListProxyImpl) reveals, that the iterator is retrieved from a copy of the list, which explains the situation. Nevertheless here an UnsupportedOperationException would be more clear than simpy to ignore the call silently.
Of course, the "real" remove() functionality would be much better :)

My Hazelcast version: 3.4.2
Example code to reproduce:
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        IList<String> list = hazelcastInstance.getList("iterate");
        list.add("the entry");
        Iterator<String> iterator = list.iterator();
        iterator.next();
        iterator.remove();
        System.out.println("list size should be 0, actual size:" + list.size());
        hazelcastInstance.shutdown();

Relevant result on console:
list size should be 0, actual size:1

Since iterator() calls listIterator() and that one calls listIterator(index), the issue is for all iterator-retrieving methods.
