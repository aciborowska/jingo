<b>What steps will reproduce the problem?</b>

To reproduce the problem we will need a queue and at least two consumer threads calling "take" on it each from a transaction context. Let's say the first thread "takes" some element within transaction. Then (due to custom processing exception) transaction is rolled back.

<b>What is the expected output? What do you see instead?</b>

We expect the "failed" element is returned to the queue and second consumer thread should "take" it successfully. 
But we always get CMF exception from the second thread instead:

> java.util.ConcurrentModificationException: Another thread holds a lock for the key : Data{partitionHash=1174106343} size= 10
>     at com.hazelcast.impl.BaseManager.throwCME(BaseManager.java:1316)
>     at com.hazelcast.impl.ConcurrentMapManager$MRemove.txnalRemove(ConcurrentMapManager.java:1054)
>     at com.hazelcast.impl.ConcurrentMapManager$MRemove.tryRemove(ConcurrentMapManager.java:1034)
>     at com.hazelcast.impl.FactoryImpl$MProxyImpl$MProxyReal.tryRemove(FactoryImpl.java:3617)
>     at com.hazelcast.impl.FactoryImpl$MProxyImpl.tryRemove(FactoryImpl.java:3108)
>     at com.hazelcast.impl.BlockingQueueManager.poll(BlockingQueueManager.java:268)
>     at com.hazelcast.impl.FactoryImpl$QProxyImpl$QProxyReal.take(FactoryImpl.java:2516)
>     at com.hazelcast.impl.FactoryImpl$QProxyImpl.take(FactoryImpl.java:2423)
>     at IssueTest$ConsumerTask.run(IssueTest.java:28)
>     at java.lang.Thread.run(Unknown Source)

<b>What version of the product are you using? On what operating system?</b>

2.0.2 on Win7 64

<b>Sample code to reproduce the issue (with output)</b>

http://gist.github.com/2234482
