This looks like a duplicate of another issue, but I just wanted to attach a quick test case to make sure. The test itself doesn't make a lot of sense, I was just trying something, but the outcome is clear.

```
java.lang.StackOverflowError
    at java.util.LinkedList.isPositionIndex(LinkedList.java:539)
    at java.util.LinkedList.checkPositionIndex(LinkedList.java:557)
    at java.util.LinkedList.listIterator(LinkedList.java:865)
    at java.util.AbstractList.listIterator(AbstractList.java:299)
    at java.util.AbstractSequentialList.iterator(AbstractSequentialList.java:239)
    at com.hazelcast.query.impl.AndResultSet$It.hasNext(AndResultSet.java:87)
    at com.hazelcast.query.impl.AndResultSet$It.hasNext(AndResultSet.java:89)
    at com.hazelcast.query.impl.AndResultSet$It.hasNext(AndResultSet.java:89)
```

TestCase:

```
import java.io.Serializable;
import java.util.Collection;
import java.util.Random;
import java.util.concurrent.ExecutionException;

import org.junit.Test;

import com.hazelcast.config.MapConfig;
import com.hazelcast.config.MapIndexConfig;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import com.hazelcast.query.EntryObject;
import com.hazelcast.query.PredicateBuilder;

public class SimpleMapTest {

   private static final int ENTRY_COUNT = 1000 * 100;
   private static final int RANGE = 100;
   private static final Random random = new Random();

   @Test
   public void test() throws InterruptedException, ExecutionException {
      final HazelcastInstance instance = Hazelcast.newHazelcastInstance();

      final String mapName = "foo";
      final MapConfig config = instance.getConfig().getMapConfig(mapName);
      config.addMapIndexConfig(new MapIndexConfig("start", true));
      config.addMapIndexConfig(new MapIndexConfig("end", true));

      final IMap<String, Range> map1 = instance.getMap(mapName);

      for (int start = 0; start < ENTRY_COUNT; start++) {
         final int end = start + random.nextInt(RANGE);
         final Range range = new Range(String.valueOf(start), start, end);
         map1.set(range.getId(), range);
      }

      int totalFound = 0;
      for (int i = 0; i < 1000000; i++) {
         final int queryStart = random.nextInt(ENTRY_COUNT);
         final int queryEnd = queryStart + RANGE;

         final EntryObject e = new PredicateBuilder().getEntryObject();
         final PredicateBuilder predicate = e.get("start").lessEqual(queryEnd).and(e.get("end").greaterEqual(queryStart));
         final Collection<Range> values = map1.values(predicate);
         totalFound += values.size();
      }
      System.err.println(String.format("Found: %s", totalFound));
   }

   static class Range implements Serializable {
      private String id;
      private long start;
      private long end;

      public Range() { }

      public Range(final String id, final long start, final long end) {
         this.id = id;
         this.start = start;
         this.end = end;
      }

      public String getId() {
         return this.id;
      }

      public long getstart() {
         return this.start;
      }

      public long getend() {
         return this.end;
      }
   }
}
```
