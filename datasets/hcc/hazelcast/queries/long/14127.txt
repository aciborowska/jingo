
```
Nov 15, 2018 11:30:20 AM com.hazelcast.internal.cluster.impl.operations.LockClusterStateOp
INFO: [10.0.0.185]:5701 [HZ] [3.12-SNAPSHOT] Locking cluster state. Initiator: [10.0.0.185]:5701, lease-time: 60000
Nov 15, 2018 11:30:20 AM com.hazelcast.internal.cluster.impl.operations.LockClusterStateOp
SEVERE: [10.0.0.185]:5701 [HZ] [3.12-SNAPSHOT] Still have pending migration tasks, cannot lock cluster state! New state: ClusterStateChange{type=class com.hazelcast.version.Version,
 newState=3.12}, current state: ACTIVE
java.lang.IllegalStateException: Still have pending migration tasks, cannot lock cluster state! New state: ClusterStateChange{type=class com.hazelcast.version.Version, newState=3.12
}, current state: ACTIVE
    at com.hazelcast.internal.cluster.impl.ClusterStateManager.checkMigrationsAndPartitionStateVersion(ClusterStateManager.java:283)
    at com.hazelcast.internal.cluster.impl.ClusterStateManager.lockClusterState(ClusterStateManager.java:215)
    at com.hazelcast.internal.cluster.impl.operations.LockClusterStateOp.run(LockClusterStateOp.java:83)
    at com.hazelcast.spi.Operation.call(Operation.java:170)
    at com.hazelcast.spi.impl.operationservice.impl.OperationRunnerImpl.call(OperationRunnerImpl.java:208)
    at com.hazelcast.spi.impl.operationservice.impl.OperationRunnerImpl.run(OperationRunnerImpl.java:197)
    at com.hazelcast.spi.impl.operationexecutor.impl.OperationExecutorImpl.run(OperationExecutorImpl.java:407)
    at com.hazelcast.spi.impl.operationexecutor.impl.OperationExecutorImpl.runOrExecute(OperationExecutorImpl.java:434)
    at com.hazelcast.spi.impl.operationservice.impl.Invocation.doInvokeLocal(Invocation.java:586)
    at com.hazelcast.spi.impl.operationservice.impl.Invocation.doInvoke(Invocation.java:571)
    at com.hazelcast.spi.impl.operationservice.impl.Invocation.invoke0(Invocation.java:530)
    at com.hazelcast.spi.impl.operationservice.impl.Invocation.invoke(Invocation.java:220)
    at com.hazelcast.spi.impl.operationservice.impl.OperationServiceImpl.invokeOnTarget(OperationServiceImpl.java:324)
    at com.hazelcast.internal.cluster.impl.ClusterStateManager.lockClusterStateOnAllMembers(ClusterStateManager.java:433)
    at com.hazelcast.internal.cluster.impl.ClusterStateManager.changeClusterState(ClusterStateManager.java:385)
    at com.hazelcast.internal.cluster.impl.ClusterStateManager.changeClusterState(ClusterStateManager.java:362)
    at com.hazelcast.internal.cluster.impl.ClusterServiceImpl.changeClusterVersion(ClusterServiceImpl.java:890)
    at hzcmd.ops.Version3_12.timeStep(Version3_12.java:11)
```


```
Nov 15, 2018 11:30:21 AM com.hazelcast.internal.cluster.impl.operations.RollbackClusterStateOp
INFO: [10.0.0.185]:5701 [HZ] [3.12-SNAPSHOT] Rolling back cluster state! Initiator: [10.0.0.185]:5701
Nov 15, 2018 11:30:21 AM com.hazelcast.internal.cluster.impl.operations.LockClusterStateOp
INFO: [10.0.0.185]:5701 [HZ] [3.12-SNAPSHOT] Locking cluster state. Initiator: [10.0.0.185]:5701, lease-time: 60000
Nov 15, 2018 11:30:21 AM com.hazelcast.internal.cluster.impl.operations.RollbackClusterStateOp
INFO: [10.0.0.185]:5701 [HZ] [3.12-SNAPSHOT] Rolling back cluster state! Initiator: [10.0.0.185]:5701
```


```
Nov 15, 2018 11:52:23 AM com.hazelcast.internal.cluster.impl.operations.LockClusterStateOp
SEVERE: [10.0.0.228]:5701 [HZ] [3.12-SNAPSHOT] Still have pending migration tasks, cannot lock cluster state! New state: ClusterStateChange{type=class com.hazelcast.version.Version, newState=3.12}, current state: ACTIVE
java.lang.IllegalStateException: Still have pending migration tasks, cannot lock cluster state! New state: ClusterStateChange{type=class com.hazelcast.version.Version, newState=3.12}, current state: ACTIVE
    at com.hazelcast.internal.cluster.impl.ClusterStateManager.checkMigrationsAndPartitionStateVersion(ClusterStateManager.java:283)
    at com.hazelcast.internal.cluster.impl.ClusterStateManager.lockClusterState(ClusterStateManager.java:215)
    at com.hazelcast.internal.cluster.impl.operations.LockClusterStateOp.run(LockClusterStateOp.java:83)
    at com.hazelcast.spi.Operation.call(Operation.java:170)
    at com.hazelcast.spi.impl.operationservice.impl.OperationRunnerImpl.call(OperationRunnerImpl.java:208)
    at com.hazelcast.spi.impl.operationservice.impl.OperationRunnerImpl.run(OperationRunnerImpl.java:197)
    at com.hazelcast.spi.impl.operationservice.impl.OperationRunnerImpl.run(OperationRunnerImpl.java:413)
    at com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.process(OperationThread.java:153)
    at com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.process(OperationThread.java:123)
    at com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.run(OperationThread.java:110)
```



this logging is repeated giving GB's of logs with this repeated msg. 

so this roll up strategy, did not work. 
```
for (( n=1; n<=${memberCount}; n++ )) ; do
        hz driver Member${n}
        hz run ${HZ_CMD_BENCH_SRC}/lab/hz/functions/shutDown >> out.txt
        hz bounce -v ${targetVersion} Member${n} >> out.txt
    done
    hz run ${HZ_CMD_BENCH_SRC}/lab/hz/functions/version_${targetVersion} >> out.txt
```


we can't change  cluster version while migrations are still pending ?
yes, since the cluster version can only be changed if all member have the same partition table


so we have to wait for cluster safe before changing version after rollup

```
for (( n=1; n<=${memberCount}; n++ )) ; do
        hz driver Member${n}
        hz run ${HZ_CMD_BENCH_SRC}/lab/hz/functions/shutDown >> out.txt
        hz bounce -v ${targetVersion} Member${n} >> out.txt
    done
    hz run ${HZ_CMD_BENCH_SRC}/lab/hz/functions/untilClusterSafe >> out.txt
    hz run ${HZ_CMD_BENCH_SRC}/lab/hz/functions/version_${targetVersion} >> out.txt
```
