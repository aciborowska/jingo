Reproduce steps...

(1) Start one hazelcast cluster member. -Xmx3G -Xmx3G -XX:-UseConcMarkSweepGC
(2) Start a client and prime one million entries of a DataSerializable object containing 14 longs, 1 Double, 1 List<String> with ~ 20 entries.  I don't believe however this is the cause, you could maybe try with primitives.  The Key is a Long
(3) Use default map config (so backup = 1)
(4) Now start a second cluster member wait for migration to complete.  Perform full GC and observe heap size. Both should be roughly same.
(5) Now add 3rd member, wait for migration to complete. Perform full GC, memory should be less than first two.
(6) Now add 4th member, wait for migration to complete. Perform full GC, memory will be less than 3rd and considerable less than members 1 & 2.

On my laptop the retained member after full GC at end of the incremental starts was :-
Member 1 : 950mb
Member 2 : 950mb
Member 3 : 750mb
Member 4 : 650mb

I performed heap dumps on Member 1 and Member 4 and noted that Member 1 (oldest) had 1.4 million com.hazelcast.nio.serialization.DefaultData entries and Member 4(youngest) had 989,000 entries. Examining Management Centre shows an even distribution of Map entries.

I tried this test again but with backups=0, started one member and primed, then added 2,3,4 members incrementally.  The memory was evenly balanced, so it appears there might be an issue with setting backups to 1 and then starting with 1 member priming a large dataset and then incrementally adding members.
