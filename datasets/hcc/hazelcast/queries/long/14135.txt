Hi, 
I'm usign hibernate 3.9.1 with hazelcast-hibernate4 with version 3.8.2 to achieve 2nd level caching. Everything goes good while I run my application as a hazelcast server. But when I switching my application to the a hazelcast client to connect a well-known standalone hazelcast server, it reads and put my entities to the Hazelcast map (seen in management center) but while I try to update the entity then it fails and gives the stacktrace below:

```
 Caused by: com.hazelcast.nio.serialization.HazelcastSerializationException: No DataSerializerFactory registered for namespace: -2000
	at com.hazelcast.internal.serialization.impl.DataSerializableSerializer.readInternal(DataSerializableSerializer.java:137)
	at com.hazelcast.internal.serialization.impl.DataSerializableSerializer.read(DataSerializableSerializer.java:105)
	at com.hazelcast.internal.serialization.impl.DataSerializableSerializer.read(DataSerializableSerializer.java:50)
	at com.hazelcast.internal.serialization.impl.StreamSerializerAdapter.read(StreamSerializerAdapter.java:48)
	at com.hazelcast.internal.serialization.impl.AbstractSerializationService.toObject(AbstractSerializationService.java:185)
	at com.hazelcast.client.impl.protocol.task.map.MapExecuteOnKeyMessageTask.prepareOperation(MapExecuteOnKeyMessageTask.java:42)
	at com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask.processMessage(AbstractPartitionMessageTask.java:62)
	at com.hazelcast.client.impl.protocol.task.AbstractMessageTask.initializeAndProcessMessage(AbstractMessageTask.java:123)
	at com.hazelcast.client.impl.protocol.task.AbstractMessageTask.run(AbstractMessageTask.java:103)
	at com.hazelcast.spi.impl.operationservice.impl.OperationRunnerImpl.run(OperationRunnerImpl.java:154)
	at com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.process(OperationThread.java:125)
	at com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.run(OperationThread.java:100)
	at ------ submitted from ------.(Unknown Source)
	at com.hazelcast.client.spi.impl.ClientInvocationFuture.resolveAndThrowIfException(ClientInvocationFuture.java:96)
	at com.hazelcast.client.spi.impl.ClientInvocationFuture.resolveAndThrowIfException(ClientInvocationFuture.java:33)
	at com.hazelcast.spi.impl.AbstractInvocationFuture.get(AbstractInvocationFuture.java:155)
	at com.hazelcast.client.spi.ClientProxy.invokeOnPartition(ClientProxy.java:204)
	at com.hazelcast.client.spi.ClientProxy.invoke(ClientProxy.java:198)
	at com.hazelcast.client.proxy.ClientMapProxy.executeOnKeyInternal(ClientMapProxy.java:1294)
	at com.hazelcast.client.proxy.ClientMapProxy.executeOnKey(ClientMapProxy.java:1287)
	at com.hazelcast.hibernate.distributed.IMapRegionCache.tryLock(IMapRegionCache.java:131)
	at com.hazelcast.hibernate.access.ReadWriteAccessDelegate.lockItem(ReadWriteAccessDelegate.java:81)
	at com.hazelcast.hibernate.region.EntityRegionAccessStrategyAdapter.lockItem(EntityRegionAccessStrategyAdapter.java:68)
	at org.hibernate.action.internal.EntityUpdateAction.execute(EntityUpdateAction.java:152)
	at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:465)
	at org.hibernate.engine.spi.ActionQueue.executeActions(ActionQueue.java:351)
	at org.hibernate.event.internal.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:350)
	at org.hibernate.event.internal.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:56)
	at org.hibernate.internal.SessionImpl.flush(SessionImpl.java:1222)
	at org.hibernate.internal.SessionImpl.managedFlush(SessionImpl.java:425)
	at org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction.beforeTransactionCommit(JdbcTransaction.java:101)
	at org.hibernate.engine.transaction.spi.AbstractTransactionImpl.commit(AbstractTransactionImpl.java:177)
	at org.hibernate.jpa.internal.TransactionImpl.commit(TransactionImpl.java:77)
	... 54 common frames omitted
```

There is another interesting point I would like to emphasis is, it is debuggable. When I adding a breakpoint to the line which throws exception above, it never suspends. But when I add a new breakpoint to the if statement of the exception, it suspends successfully and it contains factory with key -2000. 

Aforementioned line as below at DataSerializableSerializer class: 
```java
final DataSerializableFactory dsf = factories.get(factoryId);
 if (dsf == null) { // breakpoint suspends on this line
       throw new HazelcastSerializationException("No DataSerializerFactory registered for namespace: " + factoryId); // breakpoint never suspends on this line
  }
```

Any suggestions?

Thanks!