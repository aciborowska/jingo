<b>What steps will reproduce the problem?</b>
1. Build a distributed queue-based system with clients based on .poll(x, TimeUnit) usage. For example:

private Message takeMessage(IQueue&lt;? extends Message&gt; queue) throws InterruptedException {
while (!Thread.currentThread().isInterrupted()) {
Message message = queue.poll(1, TimeUnit.SECONDS);
if (message != null) {
return message;
}
}
1. Run all components and wait for half a day in silence. I mean silence is when  no data transferred between components via polled queues.
2. Check memory usage on all components during being in silence - you will see constant memory leak and in some retrospective this will definitely cause OutOfMemoryException.

<b>What is the expected output? What do you see instead?</b>
Expected output - is no memory leak.

<b>What version of the product are you using? On what operating system?</b>
1.9.4.8, 2.0
Windows 7 x64, Debian 6

<b>Please provide any additional information below.</b>
Currently there is two workarounds:
1. Change .poll to .take. Probably this workaround will work for low/medium loaded system, but for high load system you can expect this issue:
http://code.google.com/p/hazelcast/issues/detail?id=804
1. Use .poll, but you should prevent a 'silence' in your system - you should put some 'ping' messages to your queues and ignore them on .poll.

I will be very nice if next version of Hazelcast will have some internal 'pings' to avoid manual queue 'ping' mechanics.<p>Migrated from http://code.google.com/p/hazelcast/issues/detail?id=812</p>
