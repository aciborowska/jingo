Non-standard creation of `Cache`s or a crafted `URI`/`Classloader` combination may overwrite an existing `Cache`'s `cacheManager` field with a `CacheManager` that did not create the `Cache`.

```
HazelcastInstance hz = Hazelcast.newHazelcastInstance();
HazelcastInstance client = HazelcastClient.newHazelcastClient();
Properties properties = HazelcastCachingProvider.propertiesByInstanceItself(client);
CachingProvider caching = Caching.getCachingProvider("com.hazelcast.client.cache.impl.HazelcastClientCachingProvider");
CacheManager cacheManagerFoo = caching.getCacheManager(new URI("foo"), null, properties);
CacheManager cacheManagerBar = caching.getCacheManager(null, new MaliciousClassLoader(Bootstrap.class.getClassLoader()), properties);
CacheConfig cacheConfig = new CacheConfig("the-cache");
Cache cache1 = cacheManagerFoo.createCache("the-cache", cacheConfig);
// will print false, cache1.cacheManager is cacheManagerFoo
System.out.println(cache1.getCacheManager() == cacheManagerBar);
Cache cache2 = cacheManagerBar.getCache("the-cache");
// both statements below will print true
System.out.println(cache1 == cache2);
System.out.println(cache1.getCacheManager() == cacheManagerBar);

public static class MaliciousClassLoader extends ClassLoader {
        @Override
        public String toString() {
            return "foo";
        }
    }
```