If the value doesn't exist, `null` is cached in both the map and the near cache. If `evict` is called subsequently, the value in near cache is not invalidated. The behaviour is the same for 3.1.1 and 3.2-RC1.

```
import com.hazelcast.config.Config;
import com.hazelcast.config.MapConfig;
import com.hazelcast.config.NearCacheConfig;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.After;
import org.junit.BeforeClass;
import org.junit.Test;

import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

public class CachedNullValueHzTest {

    @Test
    public void testEvictNullValueNearCache() throws InterruptedException {
        final String testMap = "testMap";
        final Config config = new Config();
        final MapConfig mapConfig = new MapConfig(testMap);
        mapConfig.setNearCacheConfig(new NearCacheConfig());
        config.addMapConfig(mapConfig);
        final HazelcastInstance instance1 = Hazelcast.newHazelcastInstance(config);
        final HazelcastInstance instance2 = Hazelcast.newHazelcastInstance(config);
        final IMap<String, String> map = instance1.getMap(testMap);

        final int size = 100;

        for (int i = 0; i < size; i++) {
            assertNull(map.get("key" + i));
            map.evict("key" + i);
        }
        Thread.sleep(1000);
        for (int i = 0; i < size; i++) {
            assertNull(map.get("key" + i));
        }

        /* if the count is less, then near-cache has been used */
        assertTrue(map.getLocalMapStats().getGetOperationCount() == size * 2);

        Hazelcast.shutdownAll();
    }
}
```

Also see #795 
