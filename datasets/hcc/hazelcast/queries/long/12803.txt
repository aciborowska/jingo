The actual merging algorithm for collection like data structures (e.g. `ISet`, `IList`, `IQueue`, `Ringbuffer` and `MultiMap`) can be lossy. The issue occurs when e.g. a list contains the same value multiple times. The search for an existing entry will eliminate all duplicates in this case.

The search for existing items also has a bad complexity. It searches a new existing item for each `MergingValue`, while each merged value is added to the existing items.

The proposed solution is to give the whole collection to the merge policy and let the user decide how to merge them. This will still work for the out-of-the-box merge policies like `DiscardMergePolicy`, `PassthroughMergePolicy` and `PutIfAbsentMergePolicy`. You can also write a common merge policy for all collection based policies, by implementing `SplitBrainMergePolicy<Collection<Object>, MergingValue<Collection<Object>>`, so there is no need to write a specific one for each data structure.