```
java.lang.ClassCastException: java.util.AbstractMap$SimpleEntry cannot be cast to com.hazelcast.query.impl.QueryableEntry
    at com.hazelcast.query.Predicates$AbstractPredicate.readAttribute(Predicates.java:859)
    at com.hazelcast.query.Predicates$BetweenPredicate.apply(Predicates.java:146)
    at com.hazelcast.client.map.ClientSortLimitTest.loopingForEver_OrVeryVeryLong(ClientSortLimitTest.java:426)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.internal.runners.statements.FailOnTimeout$StatementThread.run(FailOnTimeout.java:74)
```

Code example

```
map.put(25, new Employee(25));
Predicate  pred = Predicates.between("id", 10, 50);
Collection<Employee> values = map.values(pred);

for(Employee e : values){
   Map.Entry<Integer, Employee> entry = new AbstractMap.SimpleEntry(e.id, e);
   assertTrue( pred.apply(entry) );
}
```

HazelCast code 

```
@Override
        public boolean apply(Map.Entry entry) {
            Comparable entryValue = readAttribute(entry);
            if (entryValue == null) {
                return false;
            }
            Comparable fromConvertedValue = convert(entry, entryValue, from);
            Comparable toConvertedValue = convert(entry, entryValue, to);
            if (fromConvertedValue == null || toConvertedValue == null) {
                return false;
            }
            return entryValue.compareTo(fromConvertedValue) >= 0 && entryValue.compareTo(toConvertedValue) <= 0;
        }
```

But then It really wants a QueryableEntry.

```
protected Comparable readAttribute(Map.Entry entry) {
            QueryableEntry queryableEntry = (QueryableEntry) entry;
            Comparable val = queryableEntry.getAttribute(attribute);
            if (val != null && val.getClass().isEnum()) {
                val = val.toString();
            }
            return val;
        }
```
