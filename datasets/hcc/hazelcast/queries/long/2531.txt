When multiple predicates are combined by an AndPredicate, the first IndexAwarePredicate that is not indexed will be added to the "no index" list twice.

In the filter(QueryContext queryContext) method of AndPredicate:

``` java
for (Predicate predicate : predicates) {
    boolean indexed = false;
    if (predicate instanceof IndexAwarePredicate) {
        IndexAwarePredicate iap = (IndexAwarePredicate) predicate;
        if (iap.isIndexed(queryContext)) {
            indexed = true;
            Set<QueryableEntry> s = iap.filter(queryContext);
            if (smallestIndexedResult == null) {
                smallestIndexedResult = s;
            } else if (s.size() < smallestIndexedResult.size()) {
                otherIndexedResults.add(smallestIndexedResult);
                smallestIndexedResult = s;
            } else {
                otherIndexedResults.add(s);
            }
        } else { // if not indexed, will execute this block, adding the predicate to lsNoIndexPredicates...
            if (lsNoIndexPredicates == null) {
                lsNoIndexPredicates = new LinkedList<Predicate>();
                lsNoIndexPredicates.add(predicate);
            }
        }
    }
    if (!indexed) { // ...but since indexed is still false, it will also enter this block, adding the predicate to lsNoIndexPredicates again
        if (lsNoIndexPredicates == null) {
            lsNoIndexPredicates = new LinkedList<Predicate>();
        }
        lsNoIndexPredicates.add(predicate);
    }
}
```

The else block inside the "predicate instanceof IndexAwarePredicate" block can just be removed.
