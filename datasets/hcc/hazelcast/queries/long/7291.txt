Assume two parallel http requests A and B, sticky-session set to false, deferred-write to true:

**Time tick 1:**
A: reads attributes X=1 and Y=1 from session

**Time tick 2:**
A: sets attribute X=2

**Time tick 3:**
B: reads attributes X=1 and Y=1 from session

**Time tick 4:**
B: sets attribute Y= 2

**Time tick 5:**
A: request finished. WebFilter "commits" session to distributed map

Note:
Distributed map contains X=2 and Y=1

**Time tick 6:**
B: request finished. WebFilter "commits" session to distributed map

The distributed map now contains Y=2 but again the old X=1 that was read by B but was never set. X=2 is overwritten and the data is lost.

The expected behavior is, that attributes which were only read and not modified, will not be written to the distributed map.

In general:
Reading attributes with deferred-write enabled, triggers a write operation for that value in the distributed map (maybe only, when another attribute was changed - not tested). All other changes to that value after the value was read, are overwritten.

Question regarding performance:
If you check many (lets say a few 10k values) session attributes via getAttribute (deferred-write is enabled), will all these values be written to the distributed map? It might be, that we are hitting this performance bug. Only 2-3 attributes are changed, but thousands are written to the map.
