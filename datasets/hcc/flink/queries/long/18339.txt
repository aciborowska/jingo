The  type of `datatime` field   is OBJECT_ARRAY<STRING>.

 

Exception:

 


Exception in thread "main" org.apache.flink.table.api.ValidationException: Type LEGACY(BasicArrayTypeInfo<String>) of table field 'datatime' does not match with type BasicArrayTypeInfo<String> of the field 'datatime' of the TableSource return type.Exception in thread "main" org.apache.flink.table.api.ValidationException: Type LEGACY(BasicArrayTypeInfo<String>) of table field 'datatime' does not match with type BasicArrayTypeInfo<String> of the field 'datatime' of the TableSource return type. at org.apache.flink.table.planner.sources.TableSourceUtil$$anonfun$4.apply(TableSourceUtil.scala:121) at org.apache.flink.table.planner.sources.TableSourceUtil$$anonfun$4.apply(TableSourceUtil.scala:92) at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234) at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234) at scala.collection.IndexedSeqOptimized$class.foreach(IndexedSeqOptimized.scala:33) at scala.collection.mutable.ArrayOps$ofRef.foreach(ArrayOps.scala:186) at scala.collection.TraversableLike$class.map(TraversableLike.scala:234) at scala.collection.mutable.ArrayOps$ofRef.map(ArrayOps.scala:186) at org.apache.flink.table.planner.sources.TableSourceUtil$.computeIndexMapping(TableSourceUtil.scala:92) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecTableSourceScan.translateToPlanInternal(StreamExecTableSourceScan.scala:100) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecTableSourceScan.translateToPlanInternal(StreamExecTableSourceScan.scala:55) at org.apache.flink.table.planner.plan.nodes.exec.ExecNode$class.translateToPlan(ExecNode.scala:54) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecTableSourceScan.translateToPlan(StreamExecTableSourceScan.scala:55) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecCalc.translateToPlanInternal(StreamExecCalc.scala:86) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecCalc.translateToPlanInternal(StreamExecCalc.scala:46) at org.apache.flink.table.planner.plan.nodes.exec.ExecNode$class.translateToPlan(ExecNode.scala:54) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecCalc.translateToPlan(StreamExecCalc.scala:46) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecExchange.translateToPlanInternal(StreamExecExchange.scala:84) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecExchange.translateToPlanInternal(StreamExecExchange.scala:44) at org.apache.flink.table.planner.plan.nodes.exec.ExecNode$class.translateToPlan(ExecNode.scala:54) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecExchange.translateToPlan(StreamExecExchange.scala:44) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecGroupWindowAggregate.translateToPlanInternal(StreamExecGroupWindowAggregate.scala:141) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecGroupWindowAggregate.translateToPlanInternal(StreamExecGroupWindowAggregate.scala:55) at org.apache.flink.table.planner.plan.nodes.exec.ExecNode$class.translateToPlan(ExecNode.scala:54) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecGroupWindowAggregate.translateToPlan(StreamExecGroupWindowAggregate.scala:55) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecCalc.translateToPlanInternal(StreamExecCalc.scala:86) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecCalc.translateToPlanInternal(StreamExecCalc.scala:46) at org.apache.flink.table.planner.plan.nodes.exec.ExecNode$class.translateToPlan(ExecNode.scala:54) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecCalc.translateToPlan(StreamExecCalc.scala:46) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecSink.translateToTransformation(StreamExecSink.scala:185) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecSink.translateToPlanInternal(StreamExecSink.scala:119) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecSink.translateToPlanInternal(StreamExecSink.scala:50) at org.apache.flink.table.planner.plan.nodes.exec.ExecNode$class.translateToPlan(ExecNode.scala:54) at org.apache.flink.table.planner.plan.nodes.physical.stream.StreamExecSink.translateToPlan(StreamExecSink.scala:50) at org.apache.flink.table.planner.delegation.StreamPlanner$$anonfun$translateToPlan$1.apply(StreamPlanner.scala:60) at org.apache.flink.table.planner.delegation.StreamPlanner$$anonfun$translateToPlan$1.apply(StreamPlanner.scala:59) at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234) at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234) at scala.collection.Iterator$class.foreach(Iterator.scala:893) at scala.collection.AbstractIterator.foreach(Iterator.scala:1336) at scala.collection.IterableLike$class.foreach(IterableLike.scala:72) at scala.collection.AbstractIterable.foreach(Iterable.scala:54) at scala.collection.TraversableLike$class.map(TraversableLike.scala:234) at scala.collection.AbstractTraversable.map(Traversable.scala:104) at org.apache.flink.table.planner.delegation.StreamPlanner.translateToPlan(StreamPlanner.scala:59) at org.apache.flink.table.planner.delegation.PlannerBase.translate(PlannerBase.scala:152) at org.apache.flink.table.api.internal.TableEnvironmentImpl.translate(TableEnvironmentImpl.java:439) at org.apache.flink.table.api.internal.TableEnvironmentImpl.sqlUpdate(TableEnvironmentImpl.java:348)


 

Usage:

`fieldNames` is field name array

`fieldsType` is field type array

 

We can acquire field typeinformation by the way:

 


TypeInformation typeInformation = TypeStringUtils.readTypeInfo("OBJECT_ARRAY<STRING>");


 

 


ConnectTableDescriptor d =
  descriptor.withFormat(
    new Csv().fieldDelimiter(fielddelimiter).schema(new RowTypeInfo(fieldsType,fieldNames))
  )
  .withSchema(
    schema
  );


 

(1) RowTypeInfo(fieldsType,fieldNames) calls toString method:

Row(name: String, age: Integer, sex: String, datatime: BasicArrayTypeInfo<String>)

`datatime` field type is BasicArrayTypeInfo<String>.

 

(2)Schema shema :

  schema = schema.field(fieldNames[i],fieldsType[i]);

`datatime` field type is BasicArrayTypeInfo<String>

  

 

Code analysis:

 

`schemaBuilder.field(name, type)`  is called when create TableSchema


public Builder field(String name, TypeInformation<?> typeInfo) {
   return field(name, fromLegacyInfoToDataType(typeInfo));
}

public static DataType fromLegacyInfoToDataType(TypeInformation<?> typeInfo) {
   return LegacyTypeInfoDataTypeConverter.toDataType(typeInfo);
}

public static DataType toDataType(TypeInformation<?> typeInfo) {
   // time indicators first as their hashCode/equals is shared with those of regular timestamps
   if (typeInfo instanceof TimeIndicatorTypeInfo) {
      return convertToTimeAttributeType((TimeIndicatorTypeInfo) typeInfo);
   }

   final DataType foundDataType = typeInfoDataTypeMap.get(typeInfo);
   if (foundDataType != null) {
      return foundDataType;
   }

   if (typeInfo instanceof RowTypeInfo) {
      return convertToRowType((RowTypeInfo) typeInfo);
   }

   else if (typeInfo instanceof ObjectArrayTypeInfo) {
      return convertToArrayType(
         typeInfo.getTypeClass(),
         ((ObjectArrayTypeInfo) typeInfo).getComponentInfo());
   }

   else if (typeInfo instanceof BasicArrayTypeInfo) {
      return createLegacyType(LogicalTypeRoot.ARRAY, typeInfo);
   }

   else if (typeInfo instanceof MultisetTypeInfo) {
      return convertToMultisetType(((MultisetTypeInfo) typeInfo).getElementTypeInfo());
   }

   else if (typeInfo instanceof MapTypeInfo) {
      return convertToMapType((MapTypeInfo) typeInfo);
   }

   else if (typeInfo instanceof CompositeType) {
      return createLegacyType(LogicalTypeRoot.STRUCTURED_TYPE, typeInfo);
   }

   return createLegacyType(LogicalTypeRoot.ANY, typeInfo);
}



if typeinformation is BasicArrayTypeinfo , the code is called:



else if (typeInfo instanceof BasicArrayTypeInfo) {
   return createLegacyType(LogicalTypeRoot.ARRAY, typeInfo);
}

private static DataType createLegacyType(LogicalTypeRoot typeRoot, TypeInformation<?> typeInfo) {
   return new AtomicDataType(new LegacyTypeInformationType<>(typeRoot, typeInfo))
      .bridgedTo(typeInfo.getTypeClass());
}


`datatime` field type is  LEGACY(BasicArrayTypeInfo<String>)

 

 

 

 

 

 

 

 