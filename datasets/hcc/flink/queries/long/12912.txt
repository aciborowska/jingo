BarrierBuffer#numQueuedBytes which is used to evaluate {{ task.checkpoint.alignment.max-size}} limit, is not correctly handled if one checkpoint subsumes another one.

The max size limit is checked against a sum of numQueuedBytes and bufferBlocker.getBytesBlocked(). The getBytesBlocked keeps tracks of the alignment size of the only most latest checkpoint. The bug is BarrierBuffer#releaseBlocksAndResetBarriers() method, where while handling first subsumed checkpoint in the branch:



		if (currentBuffered == null) {
			// common case: no more buffered data
			currentBuffered = bufferBlocker.rollOverReusingResources();
			if (currentBuffered != null) {
				currentBuffered.open();
			}
		}



we clear the bufferBlocker.getBytesBlocked() counter, while we do not update numQueuedBytes counter. 

For example when first checkpoint approached to 99.9% of max alignment size when it was subsumed, due to this bug calculated alignment size drops to 0 bytes. For subsequent subsumed checkpoints numQueuedBytes is correctly updated.