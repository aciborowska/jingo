Given a topology that looks like this:


DataStream<A> input = ...
input
    .map(MapFunction<A,B>...)
    .addSink(...);

input
    .map(MapFunction<A,C>...)
    â€‹.addSink(...);



enableObjectReuse() will cause an exception in the form of "java.lang.ClassCastException: B cannot be cast to A" to be thrown.

It looks like the input operator calls Output<StreamRecord<A>>.collect which attempts to loop over the downstream operators and process them.

However, the first map operation will call StreamRecord<>.replace which mutates the value stored in the StreamRecord<>.  

As a result, when the Output<StreamRecord<A>>.collect call passes the StreamRecord<A> to the second map operation it is actually a StreamRecord<B> and behaves as if the two map operations were serial instead of parallel.
