stream
 .keyBy(0)
 .timeWindow(Time.of(2500, MILLISECONDS), Time.of(500, MILLISECONDS))
 .reduce(new SummingReducer())

 // alternative: use a apply function which does not pre-aggregate
// .keyBy(new FirstFieldKeyExtractor<Tuple2<Long, Long>, Long>())
// .window(Time.of(2500, MILLISECONDS), Time.of(500, MILLISECONDS))
// .apply(new SummingWindowFunction())

 .addSink(new SinkFunction<Tuple2<Long, Long>>() {
 @Override
 public void invoke(Tuple2<Long, Long> value) {
 }
 });

 

 

if use The alternative code ,the compile doe'st comile it successfully. The api is used a serveral major version ago.

I change it to this 

.keyBy(new KeySelector<Tuple2<Long, Long>, Long>() {
 @Override
 public Long getKey(Tuple2<Long, Long> value) throws Exception 
{
 return value.f0;
 }
})
.timeWindow(Time.of(2500, MILLISECONDS), Time.of(500, MILLISECONDS))

 

private static class SummingWindowFunction implements WindowFunction<Tuple2<Long, Long>, Tuple2<Long, Long>, Long, TimeWindow> {

 @Override
 public void apply(Long key, TimeWindow window, Iterable<Tuple2<Long, Long>> values, Collector<Tuple2<Long, Long>> out) {
 long sum = 0L;
 for (Tuple2<Long, Long> value : values) 
{
 sum += value.f1;
 }

 out.collect(new Tuple2<>(key, sum));
 }
} 

And it passed


.