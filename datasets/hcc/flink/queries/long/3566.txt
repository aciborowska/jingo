Input type validation often fails when used with custom type infos. One example of this behaviour can be reproduced by creating a custom type info with our own field type:

StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

env.generateSequence(1, 10).map(new MapFunction<Long, Tuple1<Optional<Long>>>() {
			@Override
			public Tuple1<Optional<Long>> map(Long value) throws Exception 
{
				return Tuple1.of(Optional.of(value));
			}
		}).returns(new TupleTypeInfo<>(new OptionTypeInfo<Long>(BasicTypeInfo.LONG_TYPE_INFO)))
				.keyBy(new KeySelector<Tuple1<Optional<Long>>, Optional<Long>>() {

					@Override
					public Optional<Long> getKey(Tuple1<Optional<Long>> value) throws Exception 
{
						return value.f0;
					}
				});

This will fail on Input type validation at the KeySelector (or any other function for example a mapper) with the following exception:

Input mismatch: Basic type expected.