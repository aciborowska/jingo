It may cause deadlock between task canceler thread and task thread.

The detail is as follows:

Task canceler thread -> IC1#releaseAllResources -> recycle floating buffers -> lock(LocalBufferPool#availableMemorySegments) -> IC2#notifyBufferAvailable > try to lock(IC2#bufferQueue)

Task thread -> IC2#recycle -> lock(IC2#bufferQueue) -> bufferQueue#addExclusiveBuffer -> floatingBuffer#recycleBuffer -> try to lock(LocalBufferPool#availableMemorySegments)

One solution is that listener#notifyBufferAvailable can be called outside the synchronized(availableMemorySegments) in LocalBufferPool#recycle.

The existing RemoteInputChannelTest#testConcurrentOnSenderBacklogAndRecycle can cover this case but the deadlock probability is very low, so this UT is not stable.