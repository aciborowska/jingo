The definition of user define aggregations with a number of parameters larger than the row fields causes ArrayIndexOutOfBoundsException because the indexing is based on a linear iteration over row fields. This does not consider cases where fields can be used more than once and constant values are passed to the aggregation function.

for example:

window(partition {} order by [2] rows between $5 PRECEDING and CURRENT ROW aggs [myAgg($0, $1, $3, $0, $4)])



where $3 and $4 are reference to constants, and $0 and $1 are fields causes:


java.lang.ArrayIndexOutOfBoundsException: 4
	at org.apache.flink.table.plan.schema.RowSchema.mapIndex(RowSchema.scala:134)
	at org.apache.flink.table.plan.schema.RowSchema$$anonfun$mapAggregateCall$1.apply(RowSchema.scala:147)
	at org.apache.flink.table.plan.schema.RowSchema$$anonfun$mapAggregateCall$1.apply(RowSchema.scala:147)
	at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:244)
	at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:244)
	at scala.collection.Iterator$class.foreach(Iterator.scala:727)
	at scala.collection.AbstractIterator.foreach(Iterator.scala:1157)
	at scala.collection.IterableLike$class.foreach(IterableLike.scala:72)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:54)
	at scala.collection.TraversableLike$class.map(TraversableLike.scala:244)
	at scala.collection.AbstractTraversable.map(Traversable.scala:105)
	at org.apache.flink.table.plan.schema.RowSchema.mapAggregateCall(RowSchema.scala:147)
	at org.apache.flink.table.plan.nodes.datastream.DataStreamOverAggregate$$anonfun$9.apply(DataStreamOverAggregate.scala:362)

