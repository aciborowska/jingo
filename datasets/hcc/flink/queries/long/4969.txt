Using the "returns" option from the API in order to enforce the type for the data stream will lead create incorrect types for java.sql.* types. The TypeInfoParser, used to parse the types, needs to be extended to parse the java.sql.* types into the corresponding TypeInfos.

Example
= ds.map(new mapFunction()
{
    ...           
}}
) .returns(“Tuple#<java.sql.TIMESTAMP,…>”);


The problem is that if you rely on the type extraction mechanism called within the "returns()" to recognize TIMESTAMP of type SqlTimeTypeInfo it will not happen but instead a GenericType<TIMESTAMP> will be created. It is the same for the other sql types (e.g. TIME)