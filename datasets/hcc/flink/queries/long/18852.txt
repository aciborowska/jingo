Currently, the parallelism for StreamTableSourceScan/DataStreamScan is not inherited from  the upstream input, but retrieved from the config. I think this is unexpected.

I find this issue through UT, here is an example:




// env parallelism is set to 4
val env = StreamExecutionEnvironment.getExecutionEnvironment
    val tEnv = StreamTableEnvironment.create(env)
    StreamITCase.testResults = new mutable.MutableList[String]
    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)
    env.setParallelism(4)

// DataSource parallelism is set to 1
val table1 = env.fromCollection(left)
      .setParallelism(1)
      .assignTimestampsAndWatermarks(new TimestampAndWatermarkWithOffset[(Long, String)](0))
      .toTable(tEnv, 'a, 'b)
    val table2 = env.fromCollection(right)
      .setParallelism(1)
      .assignTimestampsAndWatermarks(new TimestampAndWatermarkWithOffset[(Long, String)](0))
      .toTable(tEnv, 'a, 'b)



But when you start the execution, and visualize the execution plan, you can find that the "from"(the StreamScan) operator's parallelism is 4.

   