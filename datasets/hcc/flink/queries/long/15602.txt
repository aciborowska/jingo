According to SQL 2011 Part 2 Section 6.13 General Rules 11) d)


If SD is a datetime data type or an interval data type then let Y be the shortest character string that
conforms to the definition of <literal> in Subclause 5.3, “<literal>”, and such that the interpreted value
of Y is SV and the interpreted precision of Y is the precision of SD.

That means:


select cast(cast(TO_TIMESTAMP('2014-07-02 06:14:00', 'YYYY-MM-DD HH24:mm:SS') as TIMESTAMP(0)) as VARCHAR(256)) from ...;
// should produce
// 2014-07-02 06:14:00

select cast(cast(TO_TIMESTAMP('2014-07-02 06:14:00', 'YYYY-MM-DD HH24:mm:SS') as TIMESTAMP(3)) as VARCHAR(256)) from ...;
// should produce
// 2014-07-02 06:14:00.000

select cast(cast(TO_TIMESTAMP('2014-07-02 06:14:00', 'YYYY-MM-DD HH24:mm:SS') as TIMESTAMP(9)) as VARCHAR(256)) from ...;
// should produce
// 2014-07-02 06:14:00.000000000



One possible solution would be to propagate the precision in org.apache.flink.table.planner.codegen.calls.ScalarOperatorGens#localTimeToStringCode. If I am not mistaken this problem was introduced in FLINK-14599