When use RexBuilder to build RexCall with SqlDatetimeSubtractionOperator, it will throw exception.




java.lang.IndexOutOfBoundsException: index (2) must be less than size (2)
	at com.google.common.base.Preconditions.checkElementIndex(Preconditions.java:310)
	at com.google.common.base.Preconditions.checkElementIndex(Preconditions.java:293)
	at com.google.common.collect.RegularImmutableList.get(RegularImmutableList.java:67)
	at org.apache.calcite.rex.RexCallBinding.getOperandType(RexCallBinding.java:132)
	at org.apache.calcite.sql.type.OrdinalReturnTypeInference.inferReturnType(OrdinalReturnTypeInference.java:40)
	at org.apache.calcite.sql.type.SqlTypeTransformCascade.inferReturnType(SqlTypeTransformCascade.java:54)
	at org.apache.calcite.sql.SqlOperator.inferReturnType(SqlOperator.java:470)
	at org.apache.calcite.rex.RexBuilder.deriveReturnType(RexBuilder.java:274)
	at org.apache.calcite.rex.RexBuilder.makeCall(RexBuilder.java:248)
	at com.netease.yuqi.calcatetest.TestThree.main(TestThree.java:100)




Below is My code:




public static void main(String[] args) {
		try {
			SchemaPlus rootSchema = Frameworks.createRootSchema(true);
			rootSchema.add("USERS", new AbstractTable() {
				public RelDataType getRowType(final RelDataTypeFactory typeFactory) {
					RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
					builder.add("ID", new BasicSqlType(new RelDataTypeSystemImpl() {
					}, SqlTypeName.INTEGER));
					builder.add("NAME", new BasicSqlType(new RelDataTypeSystemImpl() {
					}, SqlTypeName.CHAR));

					builder.add("TIME_D", new BasicSqlType(new RelDataTypeSystemImpl() {
					}, SqlTypeName.TIMESTAMP));
					return builder.build();
				}
			});

			rootSchema.add("TABLE_RESULT", new AbstractTable() {
				public RelDataType getRowType(final RelDataTypeFactory typeFactory) {
					RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
					builder.add("ID", new BasicSqlType(new RelDataTypeSystemImpl() {
					}, SqlTypeName.INTEGER));
					builder.add("NAME", new BasicSqlType(new RelDataTypeSystemImpl() {
					}, SqlTypeName.CHAR));
					builder.add("SCORE", new BasicSqlType(new RelDataTypeSystemImpl() {
					}, SqlTypeName.INTEGER));
					return builder.build();
				}
			});
			final FrameworkConfig config = Frameworks.newConfigBuilder()
					.parserConfig(SqlParser.Config.DEFAULT)
					.defaultSchema(rootSchema)
					.build();
			Planner planner = Frameworks.getPlanner(config);

			SqlNode parse1 = planner.parse("insert into table_result(id, name, score) select a.id as id, a.name as name, 1 from users a where month(a.time_d - interval '30' day) >= 2");
			SqlNode validate = planner.validate(parse1);

			RelRoot root = planner.rel(validate);

			RexBuilder builder1 = root.rel.getCluster().getRexBuilder();
			LogicalFilter filter = (LogicalFilter) root.rel.getInput(0).getInput(0);

                        //get RexCall of SqlDatetimeSubtractionOperator
			RexCall call = (RexCall) ((RexCall) ((RexCall) filter.getCondition()).operands.get(0)).getOperands().get(1);

			builder1.makeCall(call.getOperator(), call.getOperands());

			HepProgramBuilder builder = new HepProgramBuilder();
			//builder.addRuleInstance(FilterJoinRule.FilterIntoJoinRule.FILTER_ON_JOIN);
			//builder.addRuleInstance(FilterJoinRule.JOIN);
			builder.addRuleCollection(Programs.RULE_SET);
			HepPlanner hepPlanner = new HepPlanner(builder.build());
			hepPlanner.setRoot(root.rel);
			RelNode node = hepPlanner.findBestExp();

			System.out.println("After-------------------->");
			System.out.print(RelOptUtil.toString(node));

		} catch (Exception e) {
			e.printStackTrace();
		}
	}


