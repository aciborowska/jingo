Defined a DummyMapFunction that goes from a java Map to another java Map like this:

DummyMapFunction.scalaborderStyle=solid
class DummyMapFunction() extends MapFunction[java.util.Map[String, Any], java.util.Map[FieldName, Any]] {
  override def map(input: java.util.Map[String, Any]): java.util.Map[FieldName, Any] = {
    val result: java.util.Map[FieldName, Any] = new java.util.HashMap[FieldName, Any]()
    result
  }
}



and trying to use it with a map:

Main.java
DummyMapFunction operator = new DummyMapFunction();

DataSource<Map<String, Object>> dataset = env.fromCollection(input);
        List<java.util.Map<FieldName, Object>> collectedResult = dataset.map(operator).returns(java.util.Map.class).collect();



the returns call doesn't compile because it can't resolve the returns method with the parameter.

But if insted of creating a variable of type DummyMapFunction I create a


MapFunction operator=new DummyMapFuction();



or I explicitly cast the variable to a MapFunction, it compiles and work flawlessly.

This is a trick that works but I think is an unexpected behaviour. 