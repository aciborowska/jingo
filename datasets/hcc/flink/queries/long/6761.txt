RocksDB`s JNI bridge allows for putting and getting byte[] as keys and values. 
States that internally use RocksDB's merge operator, e.g. ListState, can currently merge multiple byte[] under one key, which will be internally concatenated to one value in RocksDB. 

This becomes problematic, as soon as the accumulated state size under one key grows larger than Integer.MAX_VALUE bytes. Whenever Java code tries to access a state that grew beyond this limit through merging, we will encounter an ArrayIndexOutOfBoundsException at best and a segfault at worst.

This behaviour is problematic, because RocksDB silently stores states that exceed this limitation, but on access (e.g. in checkpointing), the code fails unexpectedly.

I think the only proper solution to this is for RocksDB's JNI bridge to build on (Direct)ByteBuffer - which can go around the size limitation - as input and output types, instead of simple byte[].