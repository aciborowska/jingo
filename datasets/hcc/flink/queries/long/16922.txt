In Decimal:


public byte[] toUnscaledBytes() {
   if (!isCompact()) {
      return toBigDecimal().unscaledValue().toByteArray();
   }

   // big endian; consistent with BigInteger.toByteArray()
   byte[] bytes = new byte[8];
   long l = longVal;
   for (int i = 0; i < 8; i++) {
      bytes[7 - i] = (byte) l;
      l >>>= 8;
   }
   return bytes;
}


When is compact, it will return fix 8 length byte array.

This should not happen, it brings an incompatible byte array.