Following test fails:


	@Test
	public void testKeyedConnectedStreamsType() {
		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

		DataStreamSource<Integer> stream1 = env.fromElements(1, 2);
		DataStreamSource<Integer> stream2 = env.fromElements(1, 2);

		ConnectedStreams<Integer, Integer> connectedStreams = stream1.connect(stream2)
			.keyBy(v -> v, v -> v);

		KeyedStream<?, ?> firstKeyedInput = (KeyedStream<?, ?>) connectedStreams.getFirstInput();
		KeyedStream<?, ?> secondKeyedInput = (KeyedStream<?, ?>) connectedStreams.getSecondInput();
		assertThat(firstKeyedInput.getKeyType(), equalTo(Types.INT));
		assertThat(secondKeyedInput.getKeyType(), equalTo(Types.INT));
	}



The problem is that the wildcard type is evaluated as Object for lambdas, which in turn produces GenericTypeInfo<Object> for any KeySelector provided as lambda.

I suggest changing the method signature to:


	public <K1, K2> ConnectedStreams<IN1, IN2> keyBy(
			KeySelector<IN1, K1> keySelector1,
			KeySelector<IN2, K2> keySelector2)



This would be a code compatible change. Might break the compatibility of state backend (would change derived key type info). 

Still there would be a workaround to use the second method for old programs:


	public <KEY> ConnectedStreams<IN1, IN2> keyBy(
			KeySelector<IN1, KEY> keySelector1,
			KeySelector<IN2, KEY> keySelector2,
			TypeInformation<KEY> keyType)

