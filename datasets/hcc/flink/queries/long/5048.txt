The FLinkKafkaConsumer (0.9 / 0.10) spawns a separate thread that operates the KafkaConsumer. That thread is shielded from interrupts, because the Kafka Consumer has not been handling thread interrupts well.

Since that thread is also the thread that emits records, it may block in the network stack (backpressure) or in chained operators. The later case leads to situations where cancellations get very slow unless that thread would be interrupted (which it cannot be).

I propose to change the thread model as follows:


	A spawned consumer thread pull from the KafkaConsumer and pushes its pulled batch of records into a blocking queue (size one)
	The main thread of the task will pull the record batches from the blocking queue and emit the records.



This allows actually for some additional I/O overlay while limiting the additional memory consumption - only two batches are ever held, one being fetched and one being emitted.