I expect that the TypeMapper createTypeInformation and getMapReturnTypes would produce equivalent type information for the same type. But when there is a parameterized superclass, this does not appear to be the case.

Here's a test case that could be added to PojoTypeExtractorTest.java that demonstrates the issue:


public static class Pojo implements Serializable {
	public int digits;
	public String letters;
}

public static class ParameterizedParent<T extends Serializable> implements Serializable {
	public T pojoField;
}

public static class ConcreteImpl extends ParameterizedParent<Pojo> {
	public double precise;
}

public static class ConcreteMapFunction implements MapFunction<ConcreteImpl, ConcreteImpl> {
	@Override
	public ConcreteImpl map(ConcreteImpl value) throws Exception {
		return null;
	}
}

@Test
public void testMapReturnType() {
	final TypeInformation<ConcreteImpl> directTypeInfo = TypeExtractor.createTypeInfo(ConcreteImpl.class);

	Assert.assertTrue(directTypeInfo instanceof PojoTypeInfo);
	TypeInformation<?> directPojoFieldTypeInfo = ((PojoTypeInfo) directTypeInfo).getPojoFieldAt(0).getTypeInformation();
	Assert.assertTrue(directPojoFieldTypeInfo instanceof PojoTypeInfo);

	final TypeInformation<ConcreteImpl> mapReturnTypeInfo
		= TypeExtractor.getMapReturnTypes(new ConcreteMapFunction(), directTypeInfo);
	Assert.assertTrue(mapReturnTypeInfo instanceof PojoTypeInfo);
	TypeInformation<?> mapReturnPojoFieldTypeInfo = ((PojoTypeInfo) mapReturnTypeInfo).getPojoFieldAt(0).getTypeInformation();
	Assert.assertTrue(mapReturnPojoFieldTypeInfo instanceof PojoTypeInfo);

	Assert.assertEquals(directTypeInfo, mapReturnTypeInfo);
}



This test case will fail on the last two asserts because getMapReturnTypes produces a TypeInformation for ConcreteImpl with a GenericTypeInfo for the pojoField, whereas createTypeInformation correctly produces a PojoTypeInfo.