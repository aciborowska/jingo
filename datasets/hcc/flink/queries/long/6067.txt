
        val result = table.where('a < 60).select('a * 1.2,  'b / 2, 'c)


we run the above code in the Batch TableAPI/SQL, we would get the following optimizedPlan

DataSetCalc(select=[*(a, 1.2E0) AS _c0, /(b, 2) AS _c1, c])
  DataSetCalc(select=[a, b, c], where=[<(a, 60)])
    DataSetScan(table=[[_DataSetTable_0]])


However, we run the above code in the Stream TableAPI/SQL, we would get the following optimizedPlan

DataStreamCalc(select=[*(a, 1.2E0) AS _c0, /(b, 2) AS _c1, c], where=[<(a, 60)])
  DataStreamScan(table=[[_DataStreamTable_0]])



we can find that in the batch tableAPI/SQL, DataSetCalc which contains filterCondition and projects would not be choose as best path.

The reason is:
The cumulative cost of topNode of path DataSetCalc->DataSetCalc->DataSetScan is DataSetCost
{2001.0 rows, 2004.0 cpu, 0.0 io}
The cumulative cost of topNode of  path DataSetCalc->DataSetScan is DataSetCost
{2000.0 rows, 6000.0 cpu, 0.0 io}
based on isLe method of DataSetCost, compare io first, then cpu, then rows, So DataSetCalc->DataSetCalc->DataSetScan is choose as best path.