The following code currently causes problems



public class MyFunction extends RichMapFunction<A, B>  {

    private final ValueStateDescriptor<MyType> descr = new ValueStateDescriptor<>("state name", MyType.class);

    private ValueState<MyType> state;

    @Override
    public void open() {
        state = getRuntimeContext().getValueState(descr);
    }
}



The problem is that the state descriptor drops the type information and creates a serializer before serialization as part of shipping the function in the cluster. To do that, it initializes the serializer with an empty execution config, making serialization inconsistent.

This is mainly an artifact from the days when dropping the type information before shipping was necessary, because the type info was not serializable. It now is, and we can fix that bug.

