In CollectionSerializerConfigSnapshot:


@Override
public TypeSerializerSchemaCompatibility<C> resolveSchemaCompatibility(TypeSerializer<C> newSerializer) {
	if (newSerializer instanceof ListSerializer) {
		ListSerializer<T> newListSerializer = (ListSerializer<T>) newSerializer;
		ListSerializerSnapshot<T> listSerializerSnapshot = new ListSerializerSnapshot<>(newListSerializer);

		@SuppressWarnings("unchecked")
		TypeSerializerSchemaCompatibility<C> result = (TypeSerializerSchemaCompatibility<C>)
			listSerializerSnapshot.resolveSchemaCompatibility(newListSerializer);
		return result;
	} else {
		return super.resolveSchemaCompatibility(newSerializer);
	}
}



Compatibility check of ListSerializer is delegated to the new list serializer snapshot class, ListSerializerSnapshot.
However, it is incorrect to let the delegate wrap the new serializer (and therefore the new nested element serializer). By doing that, we're essentially checking compatibility of the new serializer with itself, whereas it should be checking compatibility with the restored serializer.