This can cause unexpected exceptions if the Grizzly default context configuration fails for some reason (e.g. incorrect system properties).

Here's the relevant Grizzly code in org.glassfish.grizzly.ssl.SSLFilter:


    /**
     * Build <tt>SSLFilter</tt> with the given {@link SSLEngineConfigurator}.
     *
     * @param serverSSLEngineConfigurator SSLEngine configurator for server side connections
     * @param clientSSLEngineConfigurator SSLEngine configurator for client side connections
     */
    public SSLFilter(SSLEngineConfigurator serverSSLEngineConfigurator,
                     SSLEngineConfigurator clientSSLEngineConfigurator,
                     boolean renegotiateOnClientAuthWant) {
        super(new SSLDecoderTransformer(), new SSLEncoderTransformer());
        this.renegotiateOnClientAuthWant = renegotiateOnClientAuthWant;
        if (serverSSLEngineConfigurator == null) {
            this.serverSSLEngineConfigurator = new SSLEngineConfigurator(
                    SSLContextConfigurator.DEFAULT_CONFIG.createSSLContext(),
                    false, false, false);
        } else {
            this.serverSSLEngineConfigurator = serverSSLEngineConfigurator;
        }

        if (clientSSLEngineConfigurator == null) {
            this.clientSSLEngineConfigurator = new SSLEngineConfigurator(
                    SSLContextConfigurator.DEFAULT_CONFIG.createSSLContext(),
                    true, false, false);
        } else {
            this.clientSSLEngineConfigurator = clientSSLEngineConfigurator;
        }

        handshakeCompletionHandlerAttr =
                Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(
                "SSLFilter-HandshakeCompletionHandlerAttr");
        initiatingContextAttr =
                Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(
                     "SSLFilter-HandshakingInitiatingContextAttr"
                );
    }



Note that a server SSL configuration is created even though it isn't needed. It might be a good idea to pass in our own server SSLContext even though it isn't going to be used (opposite applies to LDAPListener). For example, in com.forgerock.opendj.ldap.LDAPConnection.startTLS(), don't pass in null for the server side:


final SSLFilter sslFilter = new SSLFilter(DUMMY_SERVER, sslEngineConfigurator);

