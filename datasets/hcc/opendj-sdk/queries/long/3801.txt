When running a custom extended operation (an operation that essentially combines a single search with multiple deletes) on OpenDJ, from time to time the JE backend can end up in a deadlock state. See attached jstack for details. Debugging the process revealed absolutely no movement in the object states.


"Worker Thread 4" prio=5 tid=0x00007f90f9004000 nid=0x8103 in Object.wait() [0x0000700011272000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x00000007cce8cfc8> (a com.sleepycat.je.txn.Txn)
        at com.sleepycat.je.txn.LockManager.lockInternal(LockManager.java:351)
        at com.sleepycat.je.txn.LockManager.lock(LockManager.java:276)
        - locked <0x00000007cce8cfc8> (a com.sleepycat.je.txn.Txn)
        at com.sleepycat.je.txn.Txn.lockInternal(Txn.java:522)
        at com.sleepycat.je.txn.ReadCommittedLocker.lockInternal(ReadCommittedLocker.java:81)
        at com.sleepycat.je.txn.Locker.lock(Locker.java:443)
        at com.sleepycat.je.dbi.CursorImpl.lockLN(CursorImpl.java:2642)
        at com.sleepycat.je.dbi.CursorImpl.delete(CursorImpl.java:1354)
        at com.sleepycat.je.Cursor.deleteNoNotify(Cursor.java:2095)
        - locked <0x00000007cce8d0a8> (a com.sleepycat.je.Transaction)
        at com.sleepycat.je.Cursor.deleteInternal(Cursor.java:2059)
        at com.sleepycat.je.Cursor.delete(Cursor.java:696)
        at org.opends.server.backends.jeb.JEStorage$CursorImpl.delete(JEStorage.java:170)



The interesting part is that the thread is waiting on a lock that it already obtained previously (the wait is happening using Object.wait(0), whilst the lock was obtained via a synchronized block).