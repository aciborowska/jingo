The issue can be reproduced with the following test :


@Test
public void testMatchingRuleCorruption() throws Exception {
  String val1 = "givenName=John+cn=Doe,ou=People,dc=example,dc=com";
  String val2 = "dc=com\u0000dc=example\u0000ou=people\u0000cn=doe\u0001givenname=john";

  MatchingRule matchingRule = CoreSchema.getDistinguishedNameMatchingRule();

  ByteString normalizedValue1 = matchingRule.normalizeAttributeValue(ByteString.valueOf(val1));
  ByteString expectedValue1 = ByteString.valueOf(val2);
  assertEquals(normalizedValue1, expectedValue1);

  final SchemaBuilder builder = new SchemaBuilder("test").addSchema(Schema.getCoreSchema(), true);
  builder.addSyntax("( 1.3.6.1.4.1.1466.115.121.1.15 "
      + " DESC 'Replacing DirectorySyntax'  "
      + " X-SUBST '1.3.6.1.4.1.1466.115.121.1.15' )", true);
  Assert.assertFalse(builder.toSchema().getWarnings().isEmpty());

  normalizedValue1 = matchingRule.normalizeAttributeValue(ByteString.valueOf(val1));
  expectedValue1 = ByteString.valueOf(val2);
  assertEquals(normalizedValue1, expectedValue1);
}


Note how the same assertion first succeeds then fails with the same matching rule and same arguments.

The matching rule from the core schema is corrupted by the change made on the new "test" schema built from the core schema. 

The schema reference held by the matching rule is changed when calling void validate(final Schema schema, final List<LocalizableMessage> warnings) method.