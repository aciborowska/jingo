With DS and new schema added:

dn: cn=schema
objectClass: top
objectClass: ldapSubentry
objectClass: subschema
cn: schema
attributeTypes: ( json-attribute-oid NAME 'profile' SYNTAX 1.3.6.1.4.1.36733.2.1.3.1 EQUALITY caseIgnoreJsonQueryMatch SINGLE-VALUE X-ORIGIN 'DS Documentation Examples' X-SCHEMA-FILE '99-user.ldif' )
objectClasses: ( 1.3.6.1.4.1.36733.2.3.2.25 NAME 'profileJsonObject' SUP top AUXILIARY MAY ( profile ) X-ORIGIN 'PyForge tests' X-SCHEMA-FILE '99-user.ldif' )


I tried to do a ldapsearch with server-side sort on json attribute's inner value age.

./ldapsearch -h pyforge.example.com -p 1389 -D "cn=myself" -w password -b "dc=com" -S +profile:extensibleJsonOrderingMatch:false:true:/age "(profile=*)" profile

It looks like it sort of works, but looking at it carefully it's possible to see that it doesn't work as it should.

Here is an output of command above:

dn: uid=user_with_json.17,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 2, ... "age": 30, "surname": "17", "name": "user_with_json"}

dn: uid=user_with_json.2,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 3, ... "age": 60, "surname": "2", "name": "user_with_json"}

dn: uid=user_with_json.15,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 9, ... "age": 60, "surname": "15", "name": "user_with_json"}

dn: uid=user_with_json.19,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 4, ... "age": 60, "surname": "19", "name": "user_with_json"}

dn: uid=user_with_json.6,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 8, ... "age": 23, "surname": "6", "name": "user_with_json"}

dn: uid=user_with_json.7,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 9, ... "age": 23, "surname": "7", "name": "user_with_json"}

dn: uid=user_with_json.3,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 10, ... "age": 27, "surname": "3", "name": "user_with_json"}

dn: uid=user_with_json.1,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 1, ... "age": 29, "surname": "1", "name": "user_with_json"}

dn: uid=user_with_json.5,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 5, ... "age": 32, "surname": "5", "name": "user_with_json"}

dn: uid=user_with_json.9,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 5, ... "age": 33, "surname": "9", "name": "user_with_json"}

dn: uid=user_with_json.10,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 3, ... "age": 37, "surname": "10", "name": "user_with_json"}

dn: uid=user_with_json.12,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 5, ... "age": 38, "surname": "12", "name": "user_with_json"}

dn: uid=user_with_json.0,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 5, ... "age": 39, "surname": "0", "name": "user_with_json"}

dn: uid=user_with_json.14,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 4, ... "age": 39, "surname": "14", "name": "user_with_json"}

dn: uid=user_with_json.18,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 4, ... "age": 44, "surname": "18", "name": "user_with_json"}

dn: uid=user_with_json.16,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 6, ... "age": 49, "surname": "16", "name": "user_with_json"}

dn: uid=user_with_json.8,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 4, ... "age": 57, "surname": "8", "name": "user_with_json"}

dn: uid=user_with_json.4,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 8, ... "age": 58, "surname": "4", "name": "user_with_json"}

dn: uid=user_with_json.11,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 6, ... "age": 59, "surname": "11", "name": "user_with_json"}

dn: uid=user_with_json.13,ou=JsonOrdering,dc=example,dc=com
profile: {"countriesvisited": 5, ... "age": 59, "surname": "13", "name": "user_with_json"}

We can see an *age*s which start with 30 and continues with 60 and 60 and another 60 which is correct, but right after we have an age 23, which is not correct order. Since this age (23) the order is ok again.

It is possible to see that the json object has got also a surname field which contains numbers as strings. A same test but on surname field works as expected.

It is possible to reproduce this issue with test framework:

./run-pybot.py -v -s indexes_group.jsonOrdering opendj
