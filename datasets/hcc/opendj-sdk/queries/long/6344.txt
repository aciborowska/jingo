It is not possible to query an array of complex objects using JSON syntax attributes.

 

For example, considering this array of complex objects:

{"Top":[{"id":"234567890", "descr":"descr1"},{"id":"123123123", "descr":"descr2"} ]}

You want to be able to index it and query it using a query like "give me all users with an "id" of "123123123". You assume that arrays are JSON's way of representing multi-valued fields, so a query filter like /Top/id eq 123123123 should be sufficient. Unfortunately, this doesn't work.

 

DJ's JSON indexing  strategy is consistent with the customer's expectations: the index contains multiple records for the key /Top/id and /Top/descr.

In fact, it is the QueryFilter evaluation against the JsonValue that fails in Rest2Ldap (https://stash.forgerock.org/projects/OPENDJ/repos/opendj/browse/opendj-rest2ldap/src/main/java/org/forgerock/opendj/rest2ldap/schema/JsonQueryEqualityMatchingRuleImpl.java#698). The implementation attempts to extract the field /Top/id from the JsonValue but fails because there is no such field /Top/id: only /Top/0/id and /Top/1/id exist.

 

There's definitely a bug in DJ/Rest2Ldap because the indexing strategy is not aligned with the query filter processing. But which one is correct? It looks like JsonQueryEqualityMatchingRuleImpl is consistent with commons org.forgerock.util.query.JsonValueFilterVisitor, but even that seems a bit inconsistent. In particular, given an object:

{"Top":[ "a", "b", "c"]}

The filter /Top eq "a" is true - it's as if there is an implicit wild-card in the JsonPointer /Top/*, yet the implicit wild-carding is not supported when the array elements are not primitive types.