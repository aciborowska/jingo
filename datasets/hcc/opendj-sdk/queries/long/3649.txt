While reactive-streams contract says that one can emits data (by invoking subscriber.onNext()) from multiple thread, it also states that these invocations must not be done concurrently. Since all RxJava operators are built from this contract, violating it could cause unexpected errors.

Given that persistent-search results are sent directly from each request processing-thread (if the  entry match the psearch criteria), if two requests (for example add request) processed concurrently from two different thread, are adding a new entry matching the psearch criteria, these new entry could be emitted to the psearch FlowableEmitter concurrently from these two different thread.

Here an error which has highlighted this problem:
(ERROR) [11/Jan/2017:17:15:11 +0100] category=org.opends.messages.external severity=WARNING msgID=1 msg=GRIZZLY0011: Uncaught exception on thread Thread[LDAP Connection Handler 0.0.0.0 port 1390(5) SelectorRunner,5,main] exception=MissingBackpressureException: Inner queue full?! (FlowableFlatMap.java:284 FlowableFlatMap.java:624 FlowableOnErrorNext.java:68 FlowableMap.java:67 FlowableDoOnEach.java:89 BlockingBackpressureAwarePublisher.java:111 FlowableCreate.java:338 LdapClientConnection.java:424 SearchOperationBasis.java:888 SearchOperationBasis.java:621 SearchOperationBasis.java:397 SearchOperationWrapper.java:50 PersistentSearch.java:392 PersistentSearch.java:292 LocalBackendDeleteOperation.java:171 AbstractOperation.java:672 DeleteOperationBasis.java:272 TraditionalWorkerThread.java:148)