# Steps to Reproduce

Bean resolution fails when complementing `@Requires` constraints are placed on two `@Bean` factory methods in the same `@Factory` annotated class. Moving these methods into two different factory classes resolves the issue. 

The following fails to resolve A when Y is missing in the application context:
```java
@Factory {
public class AFactory {
  @Bean
  @Requires(beans=X.class, missingBeans=Y.class)
  public A a(X x) { 
    return A.builder().withX(x).build();
  }

  @Bean
  @Requires(beans={X.class, Y.class})
  public A a(X x, Y y) { 
    return A.builder().withX(x).withY(y).build();
  }
}
```

Placing each bean factory method in its own class resolves the issue:
```java
@Factory {
public class AFactoryWithY {
  @Bean
  @Requires(beans={X.class, Y.class})
  public A a(X x, Y y) { 
    return A.builder().withX(x).withY(y).build();
  }
}

@Factory {
public class AFactoryWithoutY {
  @Bean
  @Requires(beans=X.class, missingBeans=Y.class)
  public A a(X x) { 
    return A.builder().withX(x).build();
  }
}
```

### Expected Behaviour

The application context should resolve an instance of `A` when complementing bean factory methods annotated with `@Requires` are placed in the same `@Factory` annotated class. 

### Actual Behaviour

The bean context fails to resolve an instance of `A`.

### Environment Information

- **Operating System**: Windows
- **Micronaut Version:** 1.1.3
- **JDK Version:** 8

### Example Application

I have created a project (with unit test) containing two branches demonstrating both:
* [the failing case with two bean factory methods in the same class](https://github.com/goldsam/micronaut-bugs/tree/requires-failing-same-factory) 
* [a fix by moving bean factory methods into two classes](https://github.com/goldsam/micronaut-bugs/tree/requires-working-different-factories)

