The issue is with using the read-timeout value when connection pooling is enabled. When the connection is initialized a ReadTimeoutHandler is added to the channel, but this timeout handler appears to still be active once the request is completed. Then the channel is reused on a subsequent call it can timeout prematurely in certain cases.

### Task List

- [X] Steps to reproduce provided
- [X] Stacktrace (if present) provided
- [X] Example that reproduces the problem uploaded to Github
- [X] Full description of the issue provided (see below)

### Steps to Reproduce

1. Set read timeout of 5 seconds, connection pooling enabled with a connection pool size of 1.
2. Make a client call with a response delay of 3 seconds.
3. Wait 2001 millis.
4. Make another client call with the same response delay of 3 seconds.
5. The second call will fail with a read timeout, but it was less than the 5 seconds.

### Expected Behaviour

I expect both client requests to not timeout.

### Actual Behaviour

The seconds client call times out before the configured 5 seconds.

### Environment Information

- **Operating System**: MacOS
- **Micronaut Version:** 1.0.4
- **JDK Version:** 1.8.0_152

### Example Application

https://github.com/tomrauk/connection-pool-timeout-issue

