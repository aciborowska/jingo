In `2.0.0`.

I'm trying to debug why hotswap doesn't work for my project, during development in Idea. I use gradle build and I run services using gradle. I also use kapt instead of standard annotation processor, because the project is partially written in kotlin. My configuration (important part) is the following:

```
build.gradle
------------

    kapt {
        arguments {
            arg("micronaut.processing.incremental", true)
            arg("micronaut.processing.annotations", "io.luna.*") // this is my main package
        }
    }

    dependencies {
        kapt platform("io.micronaut:micronaut-bom:$micronautVersion")
        kapt "io.micronaut:micronaut-inject-java"
        kapt "io.micronaut:micronaut-validation"
        kaptTest platform("io.micronaut:micronaut-bom:$micronautVersion")
        kaptTest "io.micronaut:micronaut-inject-java"

gradle.properties
-----------------

kapt.include.compile.classpath=false
kapt.use.worker.api=true
kotlinVersion=1.3.71
org.gradle.parallel=true
```

Now, I'm trying to test hotswap just by changing some string inside a bean method. It randomly works and randomly says "hotswap failed, hierarchy change not implemented". I've compared build output for successful and in a nutshell here's the difference in the failed hotswaps:

![image](https://user-images.githubusercontent.com/1880196/87540885-a7c51700-c6a0-11ea-888b-68e70bb36331.png)

It seems you use a `Set` or something similar to keep superclasses, and if the order is changed, the class is reloaded and for some reason this ends up with a failed hotswap.

The other difference I've found, which didn't result in failed hotswap, but it concerns the class which didn't change, is here:

![image](https://user-images.githubusercontent.com/1880196/87541339-62551980-c6a1-11ea-8083-fb2c924d85d2.png)

I'm not 100% sure the above is a reason for failed hotswap, I'm just trying to find a solution to the problem. I don't know also why kapt decides to process these classes again on recompilation, while they weren't changed (they only refer to the singleton which were changed).

However, I think, that for the consistency, if the class weren't changed, Micronaut annotation processor should generate exactly the same bytecode as in the previous run, and this would be the desired fix for me.