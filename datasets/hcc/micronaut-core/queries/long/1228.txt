This branch contains a test `io.micronaut.security.utils.serverrequestcontextspec.ServerRequestContextReactiveSpec` which reproduces the issue: 

https://github.com/micronaut-projects/micronaut-core/tree/issue-1228

The following code snippet reproduces the issue: 

```java
@Controller("/mycontroller")
class MyController {

    @Get
    Flowable<Message> index() {
        return Flowable.just("foo")
                .flatMapSingle(name -> {
                    if (ServerRequestContext.currentRequest().isPresent()) {
                        return Single.just(new Message("Sergio"));
                    }
                    return Single.just(new Message("Anonymous"));
                });
    }

    @Get("/simple")
    Flowable<Message> simple() {
        if (ServerRequestContext.currentRequest().isPresent()) {
            return Flowable.just(new Message("Sergio"));
        }
        return Flowable.just(new Message("Anonymous"));
    }
}
```

The  line ` if (ServerRequestContext.currentRequest().isPresent()) {` in the method `index()` returns false. Because it is not able to resolve the request. 

@goeh who pointed me to this issue has done a bit research. 

He has found a couple of interesting blog posts: 

[Thread Local Availability In Reactive Environments](https://kamilszymanski.github.io/thread-local-state-availability-in-reactive-services/)

It seems Reactor has a Context (https://projectreactor.io/docs/core/release/reference/#context) and it seems Spring Security 5 uses it to store authentication info during a reactive sequence. 