Using Flowable<ByteBuffer> to stream data to a remote service should not require or enforce the use of chunking.

If the content-length is explicitly provided for an operation with a request body, then chunking is not desired and should not be used.



### Task List

- [x] Steps to reproduce provided
- [x] Stacktrace (if present) provided
- [x] Example that reproduces the problem uploaded to Github
- [x] Full description of the issue provided (see below)

### Steps to Reproduce

Trying to upload to the Oracle Object Storage REST API, using io.micronaut.http.client.RxStreamingHttpClient.
If I try to set the content of HttpRequest.PUT to a Flowable<ByteBuffer>,
micronaut removes the Content-Length header and adds Transfer-Encoding: chunked.
The server return a 500 error because it requires Content-Length.



### Expected Behaviour

If I set a Content-Length the client should not remove it and replace it with Transfer-Encoding: chunked.
Or at the least there should be an option to disable this behavior.


### Actual Behaviour

micronaut removes the Content-Length header and adds Transfer-Encoding: chunked,
in PUT and POST requests with content of type Flowable<ByteBuffer>

### Environment Information

- **Operating System**: Mac
- **Micronaut Version:** 1.3.0.M2 and 1.2.5 (I tried both)
- **JDK Version:** OpenJDK 11.0.2+9


### Example Application


If it's really required I can upload a project to github.  Let me know.

Endpoint reference:
https://docs.cloud.oracle.com/iaas/api/#/en/objectstorage/20160918/Object/PutObject

Code snippet:
    URL baseURL = new URL("https://objectstorage." + region + ".oraclecloud.com");
    RxStreamingHttpClient rxclient = RxStreamingHttpClient.create(baseURL);

     @Put(value = "/object/{namespace}/{bucket}/{name}", consumes = MediaType.ALL)
     public Flowable<ByteBuffer<?>> putObject(String namespace, String bucket, String name, 
         @Body Flowable<ByteBuffer<?>> content, @Header("Content-Length") String contentLength) {

        String path = String.format("/n/%s/b/%s/o/%s", namespace, bucket, name);
        MutableHttpRequest<?> request = HttpRequest.PUT(path, content)
                .contentType(MediaType.APPLICATION_OCTET_STREAM_TYPE)
                .accept(MediaType.ALL_TYPE)
                .contentLength(Long.parseLong(contentLength));

        //add OCI authentication header: see 
        //https://docs.cloud.oracle.com/iaas/Content/API/Concepts/signingrequests.htm#Java
        sign(request); 

        return rxclient.dataStream(request);    
    }


