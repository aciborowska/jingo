xml config:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:sharding="http://shardingsphere.io/schema/shardingsphere/sharding"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
                        http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://shardingsphere.io/schema/shardingsphere/sharding 
                        http://shardingsphere.io/schema/shardingsphere/sharding/sharding.xsd
                        http://www.springframework.org/schema/context
                        http://www.springframework.org/schema/context/spring-context.xsd
                        http://www.springframework.org/schema/tx
                        http://www.springframework.org/schema/tx/spring-tx.xsd">
    <bean name="dataSource_0" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">
        <property name="url" value="${jdbc.url_0}"/>
        <property name="username" value="${jdbc.username_0}"/>
        <property name="password" value="${jdbc.password_0}"/>
        <property name="driverClassName" value="${jdbc.driverClassName}" />
        <!-- 配置初始化大小、最小、最大 -->
        <property name="initialSize" value="${jdbc.initialSize}"/>
        <property name="minIdle" value="${jdbc.minIdle}"/>
        <property name="maxActive" value="${jdbc.maxActive}"/>
        <!-- 配置获取连接等待超时的时间 -->
        <property name="maxWait" value="${jdbc.maxWait}"/>
    </bean>
    
    <bean name="dataSource_1" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">
        <property name="url" value="${jdbc.url_1}"/>
        <property name="username" value="${jdbc.username_1}"/>
        <property name="password" value="${jdbc.password_1}"/>
        <property name="driverClassName" value="${jdbc.driverClassName}" />
        <!-- 配置初始化大小、最小、最大 -->
        <property name="initialSize" value="${jdbc.initialSize}"/>
        <property name="minIdle" value="${jdbc.minIdle}"/>
        <property name="maxActive" value="${jdbc.maxActive}"/>
        <!-- 配置获取连接等待超时的时间 -->
        <property name="maxWait" value="${jdbc.maxWait}"/>
    </bean>
    
    <bean name="globalDataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
        <property name="driverClassName" value="${jdbc.driverClassName}" />
        <!-- 配置初始化大小、最小、最大 -->
        <property name="initialSize" value="${jdbc.initialSize}"/>
        <property name="minIdle" value="${jdbc.minIdle}"/>
        <property name="maxActive" value="${jdbc.maxActive}"/>
        <!-- 配置获取连接等待超时的时间 -->
        <property name="maxWait" value="${jdbc.maxWait}"/>
    </bean>
    
    <bean id="preciseModuloDatabaseShardingAlgorithm" class="com.hundsun.ta.aop.DemoTableShardingAlgorithm" />
    <bean id="preciseModuloTableShardingAlgorithm" class="com.hundsun.ta.aop.DemoDatabaseShardingAlgorithm" />
    
    <!-- 分库策略 -->
    <sharding:standard-strategy id="databaseStrategy" sharding-column="user_id" precise-algorithm-ref="preciseModuloDatabaseShardingAlgorithm" />
    
    <!-- 分表策略 -->
    <sharding:standard-strategy id="tableStrategy" sharding-column="user_id" precise-algorithm-ref="preciseModuloTableShardingAlgorithm" />

    <sharding:data-source id="shardingDataSource">
        <!-- configDataSource为不参数分库分表的全局表的默认数据源,比如系统参数 -->
        <sharding:sharding-rule data-source-names="dataSource_0,dataSource_1,globalDataSource" default-data-source-name="globalDataSource"
        default-database-strategy-ref="databaseStrategy" default-table-strategy-ref="tableStrategy">
            <sharding:table-rules>
            	<sharding:table-rule logic-table="t_order" actual-data-nodes="dataSource_$->{0..1}.t_order_$->{0..1}" />
            	<sharding:table-rule logic-table="t_order_item" actual-data-nodes="dataSource_$->{0..1}.t_order_item_$->{0..1}" />
            	<sharding:table-rule logic-table="t_user" actual-data-nodes="dataSource_$->{0..1}.t_user"/>
            </sharding:table-rules>
            <!-- 绑定表规则列表,表示分库分表的规则相同,这样万一涉及到多个分片的查询,sharding-jdbc就可以确定分库之间不需要不必要的二次关联,所有涉及表都应该如此维护 -->
            <sharding:binding-table-rules>
                <sharding:binding-table-rule logic-tables="t_order,t_order_item"/>
            </sharding:binding-table-rules>
            <sharding:broadcast-table-rules>
                <sharding:broadcast-table-rule table="t_dict" />
            </sharding:broadcast-table-rules>
        </sharding:sharding-rule>
    </sharding:data-source>
</beans>
method io.shardingsphere.core.metadata.table.executor.TableMetaDataInitializer#getAllTableNames returns more table then current schema's table. ex. it returns table like SYS_IOT_OVER_84700。
version:sharding-sphere 3.1.0.
the reason is  getAllTableNames() method call getTables() pass null to schemaPattern in line 98. as follows:
             ResultSet resultSet = connection.getMetaData().getTables(catalog, null, null, new String[]{"TABLE"}))
the result is app suspend after datasource init.
the jstack is as follows:
"main" #1 prio=5 os_prio=0 tid=0x00000000055ad800 nid=0x154c runnable [0x000000000559c000]
   java.lang.Thread.State: RUNNABLE
        at java.net.SocketInputStream.socketRead0(Native Method)
        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
        at java.net.SocketInputStream.read(SocketInputStream.java:171)
        at java.net.SocketInputStream.read(SocketInputStream.java:141)
        at oracle.net.ns.Packet.receive(Packet.java:300)
        at oracle.net.ns.DataPacket.receive(DataPacket.java:106)
        at oracle.net.ns.NetInputStream.getNextPacket(NetInputStream.java:315)
        at oracle.net.ns.NetInputStream.read(NetInputStream.java:260)
        at oracle.net.ns.NetInputStream.read(NetInputStream.java:185)
        at oracle.net.ns.NetInputStream.read(NetInputStream.java:102)
        at oracle.jdbc.driver.T4CSocketInputStreamWrapper.readNextPacket(T4CSocketInputStreamWrapper.java:124)
        at oracle.jdbc.driver.T4CSocketInputStreamWrapper.read(T4CSocketInputStreamWrapper.java:80)
        at oracle.jdbc.driver.T4CMAREngine.unmarshalUB1(T4CMAREngine.java:1137)
        at oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:290)
        at oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:192)
        at oracle.jdbc.driver.T4C8Oall.doOALL(T4C8Oall.java:531)
        at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:207)
        at oracle.jdbc.driver.T4CPreparedStatement.fetch(T4CPreparedStatement.java:1119)
        at oracle.jdbc.driver.OracleResultSetImpl.close_or_fetch_from_next(OracleResultSetImpl.java:373)
        - locked <0x0000000780aac2a0> (a oracle.jdbc.driver.T4CConnection)
        at oracle.jdbc.driver.OracleResultSetImpl.next(OracleResultSetImpl.java:277)
        - locked <0x0000000780aac2a0> (a oracle.jdbc.driver.T4CConnection)
        at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader.getColumnMetaDataList(TableMetaDataLoader.java:137)
        at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader.load(TableMetaDataLoader.java:96)
        at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader.access$100(TableMetaDataLoader.java:52)
        at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader$1.execute(TableMetaDataLoader.java:86)
        at io.shardingsphere.core.executor.ShardingExecuteEngine.syncGroupExecute(ShardingExecuteEngine.java:175)
        at io.shardingsphere.core.executor.ShardingExecuteEngine.groupExecute(ShardingExecuteEngine.java:152)
        at io.shardingsphere.core.executor.ShardingExecuteEngine.groupExecute(ShardingExecuteEngine.java:130)

### Expected behavior
return only tables in current schema.

### Actual behavior
return tables in other schema. all table with access privilege.

### how to resolve
pass schemaName to getTables method in line 98, as follows:
             ResultSet resultSet = connection.getMetaData().getTables(catalog, dataSourceMetaData.getSchemeName(), null, new String[]{"TABLE"})) {
