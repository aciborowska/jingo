我在使用指定表分片后 ，使用非分片字段查询多次经常会线程这个问题 

java.lang.ArrayIndexOutOfBoundsException: 1
    at java.util.concurrent.CopyOnWriteArrayList.get(CopyOnWriteArrayList.java:368) ~[na:1.7.0_71]
    at java.util.concurrent.CopyOnWriteArrayList.get(CopyOnWriteArrayList.java:377) ~[na:1.7.0_71]
    at com.alibaba.druid.filter.FilterChainImpl.nextFilter(FilterChainImpl.java:405) ~[druid-1.0.9.jar:1.0.9]
    at com.alibaba.druid.filter.FilterChainImpl.connection_getAutoCommit(FilterChainImpl.java:282) ~[druid-1.0.9.jar:1.0.9]
    at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.getAutoCommit(ConnectionProxyImpl.java:212) ~[druid-1.0.9.jar:1.0.9]
    at com.alibaba.druid.pool.DruidPooledConnection.transactionRecord(DruidPooledConnection.java:689) ~[druid-1.0.9.jar:1.0.9]
    at com.alibaba.druid.pool.DruidPooledStatement.transactionRecord(DruidPooledStatement.java:131) ~[druid-1.0.9.jar:1.0.9]
    at com.alibaba.druid.pool.DruidPooledPreparedStatement.executeQuery(DruidPooledPreparedStatement.java:221) ~[druid-1.0.9.jar:1.0.9]
    at com.dangdang.ddframe.rdb.sharding.executor.PreparedStatementExecutor.executeQueryInternal(PreparedStatementExecutor.java:86) ~[sharding-jdbc-core-1.3.2.jar:na]
    at com.dangdang.ddframe.rdb.sharding.executor.PreparedStatementExecutor.access$000(PreparedStatementExecutor.java:46) ~[sharding-jdbc-core-1.3.2.jar:na]
    at com.dangdang.ddframe.rdb.sharding.executor.PreparedStatementExecutor$1.execute(PreparedStatementExecutor.java:71) ~[sharding-jdbc-core-1.3.2.jar:na]
    at com.dangdang.ddframe.rdb.sharding.executor.PreparedStatementExecutor$1.execute(PreparedStatementExecutor.java:67) ~[sharding-jdbc-core-1.3.2.jar:na]
    at com.dangdang.ddframe.rdb.sharding.executor.ExecutorEngine$1.call(ExecutorEngine.java:109) ~[sharding-jdbc-core-1.3.2.jar:na]
    at java.util.concurrent.FutureTask.run(FutureTask.java:262) ~[na:1.7.0_71]
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [na:1.7.0_71]
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [na:1.7.0_71]
    at java.lang.Thread.run(Thread.java:745) [na:1.7.0_71]

查询druid后发现是 druid中  FilterChainImpl类方法 

```
@Override
public boolean connection_getAutoCommit(ConnectionProxy connection) throws SQLException {
    if (this.pos < filterSize) {
        return nextFilter().connection_getAutoCommit(this, connection);
    }

    return connection.getRawObject().getAutoCommit();
}
```

引起的 一个 越界错误，感觉可能是因为多线程使用同一个连接导致的多线程访问导致的问题

<!---
@huboard:{"custom_state":"archived"}
-->
