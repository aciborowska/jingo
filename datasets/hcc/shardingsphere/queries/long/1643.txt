## Bug Report

### Which version of ShardingSphere did you use?

3.0.1-SNAPSHOT

### Which project did you use? Sharding-JDBC or Sharding-Proxy?

Sharding-JDBC and Sharding-Proxy

### Expected behavior

Take ShardingType.SHARDING_DATABASES for example:

The SQL is single routed to demo_ds_0.t_order.

SELECT * FROM t_order WHERE user_id = 0 LIMIT 5, 10;
10 rows are expected:
order_id: 0, user_id: 0, status: 6
order_id: 0, user_id: 0, status: 7
order_id: 0, user_id: 0, status: 8
order_id: 0, user_id: 0, status: 9
order_id: 0, user_id: 0, status: 10
order_id: 0, user_id: 0, status: 11
order_id: 0, user_id: 0, status: 12
order_id: 0, user_id: 0, status: 13
order_id: 0, user_id: 0, status: 14
order_id: 0, user_id: 0, status: 15

### Actual behavior

Get 5 rows result:
order_id: 0, user_id: 0, status: 11
order_id: 0, user_id: 0, status: 12
order_id: 0, user_id: 0, status: 13
order_id: 0, user_id: 0, status: 14
order_id: 0, user_id: 0, status: 15

### Reason analyze (If you can)

This will be happen only on single routing which do not rewrite the logical SQL's Limit sub clause.
5 rows is skipped. 5 is the offset of Limit sub clause. This is duo to offset skipping procedure in merge step.
When single routing, offset should not be skipped.

### Steps to reproduce the behavior, such as: SQL to execute, sharding rule configuration, when exception occur etc.

Take ShardingType.SHARDING_DATABASES for example:

The SQL is single routed to demo_ds_0.t_order.

SELECT * FROM t_order WHERE user_id = 0 LIMIT 5, 10;

### Example codes for reproduce this issue (such as a github link).

Offical example.