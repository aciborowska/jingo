### Which version of Sharding-Sphere do you using?

3.0.0.M2

### Which project do you using? Sharding-JDBC or Sharding-Proxy?

Sharding-JDBC

### Expected behavior

The program should only look for the "test_0" table in the "test" database.

### Actual behavior

The table "test_0" is present in the "test" database, but the program finds this table in the "test" database, but also goes to other databases (such as: "information_schema" database).

### Reason analyze

```
java.sql.SQLSyntaxErrorException: Unknown table 'test_0' in information_schema
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:120)
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97)
	at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122)
	at com.mysql.cj.jdbc.StatementImpl.executeQuery(StatementImpl.java:1218)
	at com.mysql.cj.jdbc.DatabaseMetaData$7.forEach(DatabaseMetaData.java:2965)
	at com.mysql.cj.jdbc.DatabaseMetaData$7.forEach(DatabaseMetaData.java:2953)
	at com.mysql.cj.jdbc.IterateBlock.doForAll(IterateBlock.java:56)
	at com.mysql.cj.jdbc.DatabaseMetaData.getPrimaryKeys(DatabaseMetaData.java:3006)
	at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader.getPrimaryKeys(TableMetaDataLoader.java:106)
	at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader.getColumnMetaDataList(TableMetaDataLoader.java:93)
	at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader.load(TableMetaDataLoader.java:82)
	at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader.load(TableMetaDataLoader.java:75)
	at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader.access$000(TableMetaDataLoader.java:49)
	at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader$1.call(TableMetaDataLoader.java:121)
	at io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader$1.call(TableMetaDataLoader.java:117)
	at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:117)
	at com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:38)
	at com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:77)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
```

### Steps to reproduce the behavior

1, my MySQL version is 5.7
2, MySQL driver is mysql-connector-java (8.0.12)

I am reporting an error during the startup of the program. I started the operation at 3.0.0.M1 and there is no problem. I compared the code of M1 and M2 and found that M2 will extract all the databases when starting, and extract the primary keys in the table.

### For bug report, please *MUST* provide the reproduce example codes (such as a github link).

My spring-boot (1.5.14.RELEASE)  yml configurationï¼š

```
sharding:
  jdbc:
    datasource:
      names: ds
      ds:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai
        username: test
        password: test123
        initialSize: 60
        minIdle: 60
        maxActive: 60
        maxWait: 60000
        asyncInit: true
    config:
      sharding:
        props:
          sql:
            show: true
        tables:
          test:
            actual-data-nodes: ds.test_$->{0..1}
            key-generator-column-name: id
            table-strategy:
              inline:
                sharding-column: id
                algorithm-expression: test_$->{id % 2}
```