The problem occurs whenever an association against a document contains an annotation @DBRef(lazy=true) , AND this association is defined as a parameter in the constructor of the parent document.
If the association is not defined as a parameter in the constructor everything works fine because MappingMongoConverter will use an instance of ConvertingPropertyAccessor to inject those proxies where needed later, in the "associations" phase.
MappingMongoConverter.read(MongoPersistentEntity<S>, DBObject, ObjectPath) creates a MongoDbPropertyValueProvider which is passed as a parameter to the EntityInstantiator in order to load and convert the constructor parameters of each document. These constructor parameters are retrieved in the EntityInstantiator one by one through MongoDbPropertyValueProvider's method getParameterValue(Parameter), if the parameter does not have any SpEL expression the call flow  goes down to MongoDbPropertyValueProvider.getPropertyValue(MongoPersistentProperty) which will use MappingMongoConverter.readValue(Object, TypeInformation<?>, ObjectPath) to retrieve the value of the parameter, BUT this method ALWAYS resolves the DBRef (no matter if it's lazy or not).
The issue is not visible by inspecting the returned object because the "association phase" in MappingMongoConverter.read(MongoPersistentEntity<S>, DBObject, ObjectPath) does not skip association properties already set before, and thus it fetches and converts AGAIN DBRef and sets proxies to lazy DBRef properties already resolved making the bug "invisible".