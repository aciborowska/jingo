See PR for WFLY-2640 for an example of a resource that doesn't get removed by a remove call.
In a situation like that, the AbstractRemoveStepHandler performRemove logic will never remove the resource, because it always finds it has the child. So it will just loop trying to remove the child and then calling itself again.
Possible solution is for AbstractRemoveStepHandler to have its own AttachmentKey<Set<PathAddress>> and before adding itself in a step, it adds its address to the set. Then if performRemove finds itself in the set it knows it's already tried to remove children and just removes itself.