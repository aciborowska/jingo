Apologies but I don't have time to fix this at the moment.  Besides which, I feell it's a bigger problem than I can just fix on my own...
The following is based on the way WebSphere Portal works, but it is my understanding that all JSR 168 compliant portlet containers should work in the same way.  I'd be interested if someone could demonstrate the following behaviour in other containers.
The JSR 168 spec describes portlet lifecycle with two states: a render state and an action state.  A portlet starts in its render state eg when a page that portlet is on is requested.  This corresponds to a call to that portlet's doDispatch method.  The doDispatch method for all portlets on the requested page is executed each time that page is requested. 
If we send an action request to one of the portlets on the page ie by posting a form, or clicking on an action URL, that portlet enters its action state.  This corresponds to a call to that portlet's  processAction method.  Only that portlet enters its action state and only its processAction method is executed.  However, once its action state is complete, the render state of all portlets on the current page is entered, and each portlet's doDispatch method is executed.
Most importantly, if you trigger the browser's back or refresh functionality, the page being refreshed or returned to is requested again, triggering the doDispatch method for each portlet on that page, but the processAction method is not re-executed for any of these portlets.
If we have a look at the PortletFlowController class, it has a handleRenderRequestInternal method and a handleActionRequestInternal method - these correspond to the aforementioned render and action states, respectively.  
The handleRenderRequestInternal first checks if a conversation exists: if it doesn't, eg if this is the first view state in the flow, the flow executor is called to launch a new flow, and its response instruction is used to create the first view; if it does, the response instruction from the last action state is retrieved (and then removed) from the session and used to transition to the next view state.
The handleActionRequestInternal performs whatever processing is defined in the flow and then stores its response instruction on the session for the subsequent view state.
The problem here is that if you trigger the browser's back or refresh functionality, the handleRenderRequestInternal method is re-executed for each portlet on the page without a preceding handleActionRequestInternal method, so the session is empty, which means responseInstruction is null, and so a NullPointerException is thrown when the toModelAndView method calls response.isApplicationView().
Further, consider using continuations.  The flow executor which handles continuations is called within the handleActionRequestInternal method, but if you use the browser's back button to access a portal page, only the handleRenderRequestInternal method is executed for the portlets on that page, and the result is a NullPointerException again.
I propose leaving the response instruction on the session after it is retrieved during the render state.  Further, I think that continuation handling needs to be moved to the handleRenderRequestInternal method.