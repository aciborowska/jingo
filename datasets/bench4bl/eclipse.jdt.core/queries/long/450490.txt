Here's another finding from Handly (see bug 441430). It may apply to JDT too.It is entirely possible for getChildren() to be called in one thread while addChild/removeChild is being executed in another, in which case the getChildren might be "spying" on the optimized execution of addChild/removeChild and it is possible for it to return a 'surprising' value due to reordering.Since it is known that only one thread can change the children field, but many other threads are allowed to read it at any time, declaring this field as volatile can be sufficient to attain the desired thread safety guarantees.Will push the proposed patch to Gerrit soon.Best Regards,Vladimir