This example from http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8044737 //--- public class Test { interface Constructor { MyTest execute(); } class MyTest { MyTest() { System.out.println("Constructor executed"); } } public Constructor getConstructor() { return getConstructor(() -  { return MyTest::new; }); } public static void main(String argv[]) { Test t = new Test(); MyTest mytest = t.getConstructor().execute(); } Constructor getConstructor(Wrapper arg) { return arg.unwrap(); } interface Wrapper { Constructor unwrap(); }}//---compiles fine using ecj head, but at runtime the program throws:Exception in thread "main" java.lang.VerifyError: Bad local variable typeException Details: Location: Test.lambda$0()LTest$Constructor; @0: aload_0 Reason: Type top (current frame, locals[0]) is not assignable to reference type Current Frame: bci: @0 flags: { } locals: { } stack: { } Bytecode: 0x0000000: 2aba 0026 0000 b0 at java.lang.Class.getDeclaredMethods0(Native Method) at java.lang.Class.privateGetDeclaredMethods(Class.java:2693) at java.lang.Class.privateGetMethodRecursive(Class.java:3040) at java.lang.Class.getMethod0(Class.java:3010) at java.lang.Class.getMethod(Class.java:1776) at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544) at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)The compiled method lambda$0 looks like this: private static Test$Constructor lambda$0(); flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC Code: stack=1, locals=1, args_size=0 0: aload_0 1: invokedynamic #38, 0 // InvokeDynamic #1:execute:(LTest;)LTest$Constructor; 6: areturn LineNumberTable: line 12: 0aload_0 in a static argumentless methods doesn't look right ...