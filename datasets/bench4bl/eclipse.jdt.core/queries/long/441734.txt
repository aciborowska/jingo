The following class compiles with javac.exe (JDK 8u11 x86), but fails in Eclipse (tested on 4.4.0, 4.5M1, and I20140812-0800):class Example { void foo(Iterable Number  x) { }  T  void bar(Consumer Iterable T   f) { } void test() { //call 1: lambda w/argument type - OK bar((Iterable Number  x) -  foo(x)); //call 2: lambda w/explicit type - OK this. Number  bar(x -  foo(x)); //call 3: method ref w/explicit type - OK this. Number  bar(this::foo); //call 4: lambda w/implicit type - correctly(?) fails* //bar(x -  foo(x)); //call 5: method ref w/implicit type - BUG! bar(this::foo); // errors! }}The last method call gives two errors in Eclipse:1. The method bar(Consumer Iterable T  ) in the type Example is not applicable for the arguments (this::foo)2. The type Example does not define foo(Iterable T ) that is applicable hereThe types Consumer, Iterable, and Number are arbitrary and can be replaced with any functional interface, generic type, and non-generic type (ex. Predicate, Optional, String). Giving foo a return type or additional arguments to fit a different interface does not affect the bug.The problem seems to stem from the nesting of the generic type parameter. The bug will not trigger if:- bar is changed to " T extends Iterable Number   void bar(Consumer T  f)"- All instances of Iterable _  are replaced with their parameter (T or Number)- bar is changed to "void bar(Consumer Iterable Number   f)"*Surprisingly, javac will infer the type for the implicit method reference, but not for the implicit lambda (call 4). It just assigns Object to T and gives an "incompatible types" error. Eclipse does this as well, so I assume this is somehow correct behavior.