Created attachment 2511542 test projectsWe're seeing a strange ping-pong effect when trying to compile master of org.eclipse.releng.tools and org.eclipse.jgit.On every second incremental compilation, we see this error in org.eclipse.releng.tools.git.GitCopyrightAdapter:"The type java.lang.AutoCloseable cannot be resolved. It is indirectly referenced from required .class files"The attached self-contained projects reproduce the problem (needs a 1.5 and a 1.7 Installed JRE). Just open GitCopyrightAdapter, add a space, and save. Hint: It's easier to debug without a reconciler thread: Use Open With   Text Editor.In this code path, we get the IProblem#IsClassPathCorrect as expected: at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:104) at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:187) at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.superInterfaces(BinaryTypeBinding.java:1805) at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethodInSuperInterfaces(Scope.java:1834) at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1113) at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1630) at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1525) at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2800) at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:890) at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:704) at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020) at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:638) at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307) at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:548) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590) at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:803) at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141) at java.lang.Thread.run(Thread.java:745)In the next incremental compile pass, the builder decides to build the Messages class as well. That already looks wrong to me. But as a side effect, this computes the supertypes of type String.In MethodScope(Scope).findExactMethod(ReferenceBinding, char[], TypeBinding[], InvocationSite) line: 1215, the code reads: if (isPossibleSubtypeOfRawType(argumentTypes[i])) return null;In the case where the Messages class has not been compiled before, the isPossibleSubtypeOfRawType(..) call returns true for argumentType=String (because the supertypes of String have not been resolved yet). As a consequence, Scope#findExactMethod(..) return null, and the findMethod0(..) shown above eventually resolves the type Repository and reports the missing supertype AutoCloseable.In the other case, where the compilation of class Messages already resolved the supertypes of String, the isPossibleSubtypeOfRawType(..) call returns false, and the findExactMethod(..) call returns the "resolve" method binding without ever checking the supertypes of type Repository.=  Error is not reported in this case.Two questions to investigate:1. Why does incremental compilation compile class Messages again? Is it because the previous compilation aborted due to an incomplete build path, so the next build will be a full build?2. Why does findMethod0(..) resolve the receiver type and report errors, but findExactMethod(..) sometimes returns without ever having resolved the receiver type? If the error is worth reporting at all, then it should be reported all the time.