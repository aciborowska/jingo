I can't come up with a good summary line for this one. The bug involves an plain-old interface, 2 other interfaces that use the first interface as the base type for one of their generic type parameters, and a concrete class which extends one of the interfaces, and uses the other 2 as type parameters with correlations between them. Here is the code which demos the issue:public abstract class Java8InterfaceTest{ public static interface Entity {} public static interface Service T extends Entity  {} public static interface ServiceLocator T extends Entity  {} public static class ConcreteClass T extends Entity, S extends Service T   implements ServiceLocator T  {} protected abstract  T extends Entity  ConcreteClass T, ?  getParameterized(T entity); protected  T extends Entity  ServiceLocator T  getInterface(T entity) { return getParameterized(entity); }}The method "getInterface" reports an error:Type mismatch: cannot convert from Java8InterfaceTest.ConcreteClass T,capture#1-of ?  to Java8InterfaceTest.ServiceLocator T There are 3 ways to silence this error:1. Add the suggested cast (which should not be needed) but it then warns you that the cast is unneeded, so you also need to add a SuppressWarnings annotation.2. Use the explicit type parameter override notation: return this. T getParameterized(entity);3. Change the getParameterized() method to return ConcreteClass T, Service T  .None of these workarounds should be necessary since this code compiles fine with Javac for Java 7 and 8.