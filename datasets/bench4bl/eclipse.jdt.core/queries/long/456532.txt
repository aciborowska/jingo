In error messages when printing a type variable that is constrained by a null-annotated bound, the null annotation may bogusly be repeated before the type variable itself.Witness: ExternalAnnotations18Test.testLibsWithTypeParameters() in the feature branch for external null annotations (to be pushed soon).Current draft fix looks like this (but causes regressions): //---protected void appendNullAnnotation(StringBuffer nameBuffer, CompilerOptions options) { if (options.isAnnotationBasedNullAnalysisEnabled) { // restore applied null annotation from tagBits: if ((this.tagBits   TagBits.AnnotationNonNull) != 0) { if (!appendAnnotationName(nameBuffer, this.typeAnnotations, TypeIds.T_ConfiguredAnnotationNonNull)) { TypeBinding prototype = this.unannotated(); if (prototype != null) appendAnnotationName(nameBuffer, prototype.typeAnnotations, TypeIds.T_ConfiguredAnnotationNonNull); } } if ((this.tagBits   TagBits.AnnotationNullable) != 0) { if (!appendAnnotationName(nameBuffer, this.typeAnnotations, TypeIds.T_ConfiguredAnnotationNullable)) { TypeBinding prototype = this.unannotated(); if (prototype != null) appendAnnotationName(nameBuffer, prototype.typeAnnotations, TypeIds.T_ConfiguredAnnotationNullable); } } }}private boolean appendAnnotationName(StringBuffer buffer, AnnotationBinding[] annotations, int typeId) { for (AnnotationBinding annot : annotations) { if (annot.type == null || annot.type.id != TypeIds.T_ConfiguredAnnotationNonNull) continue; buffer.append('@').append(annot.type.sourceName()).append(' '); return true; } return false;}//---