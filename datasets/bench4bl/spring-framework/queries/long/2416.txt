2.0RC2 contained a change (SPR-2156) that breaks a number of very useful features, and IMHO is contrary to the how Java classloading is intended to work.
In particular, if I have a hierarchy of ApplicationContexts where some of the leaves are in .war or .ear files, then the leaf contexts are most likely referencing classes that are in the .war or .ear, and therefore require a different classloader than the parent contexts. The classloader in all likelihood is part of a hierarchy that mirrors the ApplicationContext hierarchy. This is the situation in JBoss in particular - at least if isolation is on and/or during hot-(re)deploy, and of course Java deals with this using the TCCL mechanism. Even if most JBoss users don't use isolation, it does use a different classloader during hot-(re)deploy. Furthermore other containers may correctly implement isolation which will make this problem more obvious.
The workaround is to null the classloader on the ResourceLoader in a bean post-processor, which I do by specifing a custom classloader-nulling ApplicationContext in the node in my hierarchy that corresponds to a classloader hierarchy boundary. I don't think users should have to do this for what is after all a fundamental feature of war/ear classloading design (even if JBoss ignores it by default), especially breaking hot-redeploy.
I must admit I'm not sure of the use case that motivated the change. For a change with such a significant chance of breakage, I was surprised that I couldn't find it listed in the 2.0RC2 changelog.
