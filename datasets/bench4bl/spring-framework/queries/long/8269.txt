When using AnnotationConfigApplicationContext, if I declare at least one @Bean of type BeanFactoryPostProcessor (even if it's a stub that doesn't do anything), this breaks default post-processing of the @Configuration bean, meaning that @Autowired fields are no longer injected, @PostConstruct methods are not called, etc.
I'm attaching a test case to prove my point.
A workaround is to manually add the relevant BeanPostProcessors (like AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor) to BeanFactory.
Same thing happens in web app when I use ContextLoaderInitializer to load @Configuration classes or define them through XML config. My particular case is that I use MyBatis-Spring integration and I cannot declare a @Bean of type org.mybatis.spring.mapper.MapperScannerConfigurer using annotation config, because this bean is a BeanFactoryPostProcessor and thus breaks autowiring of @Configuration class.