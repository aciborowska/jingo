If the isBridgeMethodFor method in the BridgeMethodResolver class is called with a bridge method which has a parameter of type java.lang.reflect.ParameterizedType (for example Class<T>), a ClassCastException is thrown.
This issue is due to the fact that in the isBridgeMethodFor method calls the private isResolvedTypeMatch method. In this method, the generic parameter types are extracted from the generic method (i.e. from the generic declaration whose erased signature matches that of the supplied bridge method). Then, each generic parameter is either cast to a java.lang.reflect.TypeVariable if it is an instance of TypeVariable, and then resolved using a type variable map and cast to java.lang.Class, or, if it is not an instance of TypeVariable, it is cast immediately to java.lang.Class. However, if a generic parameter is an instance of java.lang.reflect.ParameterizedType, the isResolvedTypeMatch method tries to cast this parameter immediately to java.lang.Class (since it is not an instance of TypeVariable), which results in a ClassCastException, since the type of this generic parameter (which is for example sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl, an implementation of the ParameterizedType interface) is cast to java.lang.Class.
The following example demostrates this. If we have the following bridge method: Class<T> getFor(Class<T>), whose parameter is of type ParameterizedTypeImpl, a ClassCastException is thrown, since the isResolvedTypeMatch method tries to cast ParameterizedTypeImpl to java.lang.Class.
The solution would be to treat the case if a generic type parameter is of type ParameterizedType separately in the isResolvedTypeMatch method of the BridgeMethodResolver class.