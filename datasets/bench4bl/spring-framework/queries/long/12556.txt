I suspect this is the reason for a CGLIB-related memory leak I see (resembling very close https://jira.spring.io/browse/SPR-8008), but the issue is so complicated I'm not sure.
We are creating and destroying a Spring context having a JPA entity. What we see in the dump is an instance of AdvisedSupport per context ever created, referenced by CglibAopProxy$ProxyCallbackFilter referenced by CGLIB EnhancerKey (having the matching number of instances). The EnhancerKeys are all different because the Filters are different and these are different because they have a PersistenceExceptionTranslationAdvisor whose instances are compared by advice and pointcut. The advice is PersistenceExceptionTranslationInterceptor which doesn't override equals so all instances are different. 
Now judging by the hashmap structure, the hashkey of them all seem to be the same which further strengthens my hypothesis.
I couldn't tell whether the approach of hashCode or the approach of equals is correct but they are not consistent. If we take the approach of hashCode, all instances of AbstractPointcutAdvisor would be the same. However if equals implementation is the correct one, the result is a memory leak because of the advisors being referenced by CglibAopProxy$ProxyCallbackFilter instances which are strongly referenced by the CGLIB cache.