DataSourceUtils.suspend() has been changed in version 1.2.6 to release a connection on suspend if the application doesn't keep a handle to it anymore. If working with more than one connection in a transaction this can cause problems with the TransactionSynchronizationManager in the AbstractPlatformTransactionManager.suspend(Object) method.
If you have two transactions running, one within the other with a propogation of "PROPOGATION_REQUIRES_NEW", then when the inner transaction runs, the connections in the suspendedSynchronizations list within the AbstractPlatformTransactionManager.suspend(Object) are released on suspension in DataSourceUtils.suspend(), (since 1.2.6). If the inner transaction is running within a loop then on the second run of the loop, the AbstractPlatformTransactionManager.suspend(Object) will try to release the connections again using DataSourceUtils.suspend(), resulting in  IllegalArgumentException : Active Connection is required.
The following pseudo-code below can reproduce the exception.
        // Set up two Data Sources to two different databases....
        LazyConnectionDataSourceProxy dataSourceA = ................
        ..............
        ...............
        LazyConnectionDataSourceProxy dataSourceB = ................
        ..............
        ...............
        // Set up a Jdbc template for each Datasource....
        final JdbcTemplate jdbcTemplateA = new JdbcTemplate(dataSourceA);
        final JdbcTemplate jdbcTemplateB = new JdbcTemplate(dataSourceB);
        // Set up Transaction Template on dataSourceA with PROPAGATION_REQUIRES_NEW....
        DataSourceTransactionManager dstm = new DataSourceTransactionManager(dataSourceA);
        ptm.afterPropertiesSet();	        
        final TransactionTemplate transactionTemplate = new TransactionTemplate();
        transactionTemplate.setTransactionManager(dstm);
        transactionTemplate.setPropagationBehavior( TransactionTemplate.PROPAGATION_REQUIRES_NEW );
        transactionTemplate.afterPropertiesSet();
        // Execeute outer transaction.........
        transactionTemplate.execute( new TransactionCallbackWithoutResult() {
    		public void doInTransactionWithoutResult(TransactionStatus status) {
                                          Execute a query using both connections.........                         
		jdbcTemplateA.execute( "select top 1 * from TableA"); 
                                           jdbcTemplateB.execute( "select top 1 * from TableB" );
                                          // Loop round inner transaction - exception is thrown in second loop............
               	                     for (int j=0; j < 2; j++) {         		
               		         transactionTemplate.execute( new TransactionCallbackWithoutResult() {
    					public void doInTransactionWithoutResult(TransactionStatus status) {}
    				});
               	}
    	    }		
        } );