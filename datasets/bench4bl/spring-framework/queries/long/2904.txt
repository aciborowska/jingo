I've implemented some around advice to retry a transaction, very similar to the ConcurrentOperationExecutor example in the Spring AOP documentation.  Executing proceed() multiple times on the ProceedingJoinPoint (which is an instance of org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint) works just fine - the interceptors further down the chain (TransactionInterceptor in this case) get executed every time proceed is called.  However, calling proceed(Object[] args) multiple times does not work - the interceptors further down the chain are executed only the first time proceed(Object[] args) is called, but not on subsequent calls.  Looking at the source code for MethodInvocationProceedingJoinPoint, this seems to be because ReflectiveMethodInvocation.invocableClone() is called in the plain proceed() method, thus ensuring that the currentInterceptorIndex is preserved on each retry.  This cloning is not done in proceed(Object[] args), thus the currentInterceptorIndex is not preserved for the retry and subsequent interceptors are not invoked.  I didn't see anything indicating that proceed(Object[] args) was not intended to be called multiple times - is this a bug?  Can proceed(Object[] args) just call invocableClone() also?