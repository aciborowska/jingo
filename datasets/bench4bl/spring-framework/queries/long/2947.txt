If you turn on AspectJ load-time weaving then Spring AOP no longer will accept @AspectJ aspects. The issue is that in AbstractAspectJAdvisorFactory it looks for methods starting with AJC_MAGIC (ajc$) but the AspectJ LTW system creates a method like this ajc$postClinit even if the aspect isn't registered for AspectJ load-time weaving (it completes annotation-defined aspects even if they aren't registered for weaving).
Work-around - exclude the Spring AOP aspect from AspectJ load-time weaving, e.g.,
        <exclude within="org.springframework.samples.jpetstore.aspects.SqlMapMonitor"/>
Note that the AspectJ load-time weaving system just tests for the presence of the org.aspectj.lang.annotation.Aspect annotation on the type. Why can't the advisor factory just do that? Indeed, why not just allow registration of code-style aspects that were compiled with -target 1.5 or later so that they can also be used with Spring AOP? If you don't want to apply all aspects, then don't auto-proxy? It's also interesting to consider the bigger issue of how Spring AOP should integrate with load-time weaving.