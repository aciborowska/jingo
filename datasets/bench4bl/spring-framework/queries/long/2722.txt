We are integrating Spring into an existing system.  Since some of the code in the legacy system does manual programmatic transaction management, we need to suspend the Spring transaction in order to call it.  However, we also need to be able to invoke transactional Spring services from within this legacy context, so in certain edge cases we will have transactional stuff invoked from code where no Spring transaction is active, yet database updates will be necessary.
To do this, we first suspend the Spring transaction using PROPAGATION_NOT_SUPPORTED.  Then, we get a connection from the pool, do some straight JDBC and then programmatically commit/rollback and release the connection.  This all works fine, however, if this code also needs to invoke a Spring-enabled transactional service, the JDBC work done within the context of the PROPAGATION_NOT_SUPPORTED 'transaction' gets enlisted and committed by the transactional service.  This happens if either PROPAGATION_REQUIRES_NEW or PROPAGATION_REQUIRED is used.
I have a junit test case which illustrates this nicely and I will attach it to this issue.